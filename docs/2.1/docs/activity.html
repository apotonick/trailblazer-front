<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
    <title>Trailblazer</title>
    <meta content="width=device-width,initial-scale=1" name="viewport"/>
    
    
    <link rel="stylesheet" href="/assets/tailwind-603662ff03e9d907d1b9aacb9742fe2d5430cff2e8033b6f706a29af2b22d528.css" data-turbo-track="reload" />
<link rel="stylesheet" href="/assets/inter-font-8c3e82affb176f4bca9616b838d906343d1251adc8408efe02cf2b1e4fcf2bc4.css" data-turbo-track="reload" />
    <link rel="stylesheet" href="/assets/application-0aad967f02ae30cc09abfb66068870c30a6ebef02335739e965608eab1f44a12.css" data-turbo-track="reload" />
    <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/styles/atom-one-dark.min.css" />
    <script type="importmap" data-turbo-track="reload">{
  "imports": {
    "application": "/assets/application-ef7cae4e5d2044880dfe68a764c3ef494a1157257e0b8c9a6dddacae038ee17c.js",
    "scrollspy": "/assets/scrollspy-95d60a754e254e9c814d7dc686800b0bb81f184888fe72911a94485f9f705a66.js",
    "navigations": "/assets/navigations-381280bcc80b41e40a7cbad99588e7aafc64b217c2272d231d2223bc5b7b073e.js",
    "anchor-js": "/assets/anchor-js-821952d04abcd941bb3541822cd1c1f0234e5168bef1f9b2a050868af608aa5a.js",
    "scrollmagic": "/assets/scrollmagic-fe2032c0c4e64c54cbe40894eec87821277108e36a296c8ee15c114cf4cbdf82.js",
    "highlight.js/lib/core": "https://ga.jspm.io/npm:highlight.js@11.8.0/es/core.js",
    "highlight.js/lib/languages/ruby": "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/es/languages/ruby.min.js"
  }
}</script>
<link rel="modulepreload" href="/assets/application-ef7cae4e5d2044880dfe68a764c3ef494a1157257e0b8c9a6dddacae038ee17c.js">
<link rel="modulepreload" href="/assets/scrollspy-95d60a754e254e9c814d7dc686800b0bb81f184888fe72911a94485f9f705a66.js">
<link rel="modulepreload" href="/assets/navigations-381280bcc80b41e40a7cbad99588e7aafc64b217c2272d231d2223bc5b7b073e.js">
<link rel="modulepreload" href="/assets/anchor-js-821952d04abcd941bb3541822cd1c1f0234e5168bef1f9b2a050868af608aa5a.js">
<link rel="modulepreload" href="/assets/scrollmagic-fe2032c0c4e64c54cbe40894eec87821277108e36a296c8ee15c114cf4cbdf82.js">
<script src="/assets/es-module-shims.min-4ca9b3dd5e434131e3bb4b0c1d7dff3bfd4035672a5086deec6f73979a49be73.js" async="async" data-turbo-track="reload"></script>
<script type="module">import "application"</script>
  </head>
  <body>
    <nav class="lg:flex lg:justify-between lg:items-center lg:h-[5.5rem] lg:px-[5.5rem] lg:z-30 bg-white text-base py-3 z-10 sticky top-0" id="navbar">
  <a href="/2.1" class="block shrink-0 w-fit mx-auto lg:mx-0">
    <img class="w-40 lg:my-0" src="/assets/logo_blue_ruby-e87334a67ff20033fae8c8d2c07e549b5f1faa9b75bb07fbb2ff9d1c0dfef6e7.svg" />
  </a>
  <div class="lg:hidden absolute right-4 top-2 flex w-9 h-9 items-center" id="hamburgerIcon">
    <div class="pointer-events-none w-full h-0.5 bg-blue transition-all duration-150
                  before:content-[''] before:absolute before:w-full before:h-0.5 before:bg-blue before:-translate-y-2.5 before:transition-all before:duration-150
                  after:content-[''] after:absolute after:w-full after:h-0.5 after:bg-blue after:translate-y-2.5 after:transition-all after:duration-150"></div>
  </div>
  <div class="lg:hidden flex flex-col text-center hidden" id="navList">
    <div class="lg:absolute flex flex-col mt-15 gap-10 uppercase">
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="/2.1/docs">Documentation</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="/2.1/blog">Blog</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="/2.1/about">About</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="#">Community</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="#">Learn</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="#">Chat with us</a>
    </div>
  </div>
  <div class="lg:flex hidden gap-10 items-center">
    <div class="flex gap-7">
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="/2.1/docs">Documentation</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="/2.1/blog">Blog</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="/2.1/about">About</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="#">Community</a>
      <a class="font-medium text-base uppercase hover:scale-110 lg:normal-case lg:font-semibold" href="#">Learn</a>
    </div>
    <a class="base-button text-base w-[12.5rem] h-[3.25rem] bg-light-purple text-blue hover:scale-105 hover:text-white hover:bg-purple" href="#">Chat with us</a>
  </div>
</nav>

<section>
  <div class="lg:hidden bg-bg-blue text-white fixed left-0 top-20 pr-1 py-3 rounded-r" id="sideNavShowButton" style="writing-mode: vertical-rl; text-orientation: upright;">
    Chapters
  </div>
  <div class="lg:flex">
    <nav class="documentation-side-nav" id="sideNav">
      <div class="lg:hidden absolute right-4 top-4 text-3xl text-white" id="sideNavHideButton">
        X
      </div>
      <div class="lg:pt-0 lg:pl-6 xl:pl-20 p-10 pl-20 text-white text-base leading-10">
  
     <!-- # TODO: abstract to torture-cms -->

    <div class="flex flex-col pt-10">
      <a href="/2.1/docs/activity/index.html" class="font-bold pl-3 bg-selected">Activity</a>
      
        <a href="#activity-overview" class="pl-3">Overview</a>
      
        <a href="#activity-strategy" class="pl-3">Strategy</a>
      
        <a href="#activity-wiring-api" class="pl-3">Wiring API</a>
      
        <a href="#activity-dsl-options" class="pl-3">DSL Options</a>
      
        <a href="#activity-variable-mapping" class="pl-3">Variable Mapping</a>
      
        <a href="#activity-dependency-injection" class="pl-3">Dependency Injection</a>
      
        <a href="#activity-macro-api" class="pl-3">Macro API</a>
      
        <a href="#activity-internals" class="pl-3">Internals</a>
      
        <a href="#activity-taskwrap" class="pl-3">TaskWrap</a>
      
        <a href="#activity-troubleshooting" class="pl-3">Troubleshooting</a>
      
    </div>
  
     <!-- # TODO: abstract to torture-cms -->

    <div class="flex flex-col pt-10">
      <a href="/2.1/docs/macro/index.html" class="font-bold pl-3 ">Macro</a>
      
    </div>
  
     <!-- # TODO: abstract to torture-cms -->

    <div class="flex flex-col pt-10">
      <a href="/2.1/docs/operation/index.html" class="font-bold pl-3 ">Operation</a>
      
    </div>
  
    
</div>

    </nav>
    <div class="lg:p-10 pl-8 pr-4 py-10 bg-light-grey grow">
      <h1 class="lg:text-3xl text-2xl text-blue font-bold">
        <span class="font-black uppercase">
          Activity
        </span>
        Documentation
      </h1>
      <!-- <div class="text-base leading-10">
        <span class="font-bold text-bg-blue">
          Subject A |
        </span>
        <span class="text-purple">
          Subject 02
        </span>
      </div> -->
      <div class="xl:flex xl:gap-0.5 mt-5">
        <div class="max-w-3xl lg:p-8 lg:pb-14 p-4 bg-white text-bg-blue" id="documentation">
          <h2 id="activity-overview" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Overview</h2>

<p class="mt-6">An activity is an executable <em>circuit</em> of tasks. Each task is arbitrary Ruby code, usually encapsulated in a callable object. Depending on its return value and its outgoing connections, the next task to invoke is picked.</p>

<p class="mt-6">Activities are tremendously helpful for modelling and implementing any kind of logic and any level of complexity. They’re useful for a hash merge algorithm, an application’s function to validate form data and update models with it, or for implementing long-running business workflows that drive entire application lifecycles.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
The `activity` gem is an extraction from Trailblazer 2.0, where we only had operations. Operations expose a linear flow which goes into one direction, only. While this was a massive improvement over messily nested code, we soon decided it's cool being able to model non-linear flows. This is why activities are the major concept since Trailblazer 2.1.

</p>
</div>

<h3 id="activity-overview-anatomy" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Anatomy</h3>

<p class="mt-6">To understand the mechanics behind Trailblazer’s activities, you need to know a few simple concepts.</p>

<ol>
  <li>An <strong>activity</strong> is a circuit of tasks - boxes being connected by arrows.</li>
  <li>It has one <strong>start</strong> and at least one <strong>end event</strong>. Those are the circles in the diagrams.</li>
  <li>A <strong>task</strong> is a unit of business logic. They’re visualized as boxes. This is where your code goes!</li>
  <li>Each task has one or more <strong>outputs</strong>. From one particular output you can draw one connecting line to the next task.</li>
  <li>An output is triggered by a <strong>signal</strong>. The last line in a task usually decides what output to pick, and that happens by <code class="text-purple">return</code>ing a specific object, a signal.</li>
  <li>Besides the signal, a <strong>semantic</strong> is assigned to an output. This is a completely arbitrary “meaning”. In Trailblazer, we use <code class="text-purple">success</code> and <code class="text-purple">failure</code> as conventional semantics.</li>
  <li>In a railway activity, for instance, the “failure” and “success” track mean nothing more than following the <code class="text-purple">failure</code> or <code class="text-purple">success</code>-labeled outputs. That’s a <strong>track</strong>.</li>
</ol>

<p class="mt-6">Activities can be visualized neatly by taking advantage of the BPMN specification.</p>

<p class="mt-6"><img src="/assets/intermediate-cbd976784e47bdf1321454717b7c0871c245b75cf7dfd889a969ec482c40697d.webp" /></p>

<p class="mt-6">Well, this is not entirely BPMN, but you get the idea. Intuitively, you understand that the tasks <code class="text-purple">B</code> and <code class="text-purple">C</code> have only one outcome, whereas <code class="text-purple">A</code> yields two possible results. This works by adding two <em>outputs</em> to <code class="text-purple">A</code>.</p>

<p class="mt-6">An output is a combination of a <em>semantic</em> and a <em>signal</em>. A part of the return value of the invoked task is interpreted as a signal, and that’s how Trailblazer picks the connection to the next task to take.</p>

<p class="mt-6">Depending on <code class="text-purple">A</code>’s’ returned signal (yet to be defined), the flow will continue on its <code class="text-purple">success</code> or <code class="text-purple">failure</code> connection. It’s completely up to the modelling developer what names they choose for semantics, and how many outputs they need. Nevertheless, for binary outputs we usually take <code class="text-purple">success</code> and <code class="text-purple">failure</code> as meaningful semantics.</p>

<h3 id="activity-overview-dsl" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">DSL</h3>

<p class="mt-6">To implement our activity, we can use Activity’s DSL.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
To demonstrate the concepts of an activity, we make use of the DSL. This simplifies defining activities. However, keep in mind that you're free to build activities using the PRO editor, with your own DSL or with our [low-level API].

</p>
</div>

<pre class="mt-4"><code class="rounded">class Upsert &lt; Trailblazer::Activity::Path
  step :find_model, Output(Trailblazer::Activity::Left, :failure) =&gt; Id(:create)
  step :update
  step :create, magnetic_to: nil, Output(Trailblazer::Activity::Right, :success) =&gt; Id(:update)

  # ...
end
</code></pre>

<p class="mt-6">The <code class="text-purple">Activity::Path</code> class is the simplest DSL strategy. It automatically connects each <code class="text-purple">step</code> to the previous one, unless you use the <code class="text-purple">:magnetic_to</code> option. In our case, this is necessary to connect <code class="text-purple">#find</code> (A) to <code class="text-purple">#create</code> (C). The <code class="text-purple">Output</code> method helps to define what signal and semantic an output has, and using <code class="text-purple">Id</code> you can point those to a specific neighbor task.</p>

<p class="mt-6">If unsure, use the [developer tools] to render the circuit.</p>

<pre class="mt-4"><code class="rounded">Trailblazer::Developer.render(A::Upsert)
</code></pre>

<p class="mt-6">Alternatively, use the PRO editor tools.</p>

<h3 id="activity-overview-invocation" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Invocation</h3>

<p class="mt-6">Before you can use your activity, the tasks need to be written. Using the [task interface] this is pretty straight-forward. Note that you can return either a boolean value or a [signal subclass] in order to dictate the direction of flow.</p>

<pre class="mt-4"><code class="rounded">class Upsert &lt; Trailblazer::Activity::Path
  # ...

  def find_model(ctx, id:, **) # A
    ctx[:memo] = Memo.find(id)
    ctx[:memo] ? Trailblazer::Activity::Right : Trailblazer::Activity::Left # can be omitted.
  end

  def update(ctx, params:, **) # B
    ctx[:memo].update(**params)
    true # can be omitted
  end

  def create(ctx, **)
    ctx[:memo] = Memo.new
  end
end
</code></pre>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
You don't have to stick to the task interface! The [circuit interface] is a bit more clumsy, but gives you much better control over how ctx and signals are handled.

</p>
</div>

<p class="mt-6">To run your activity, use its <code class="text-purple">call</code> method. <code class="text-purple">Activity</code>s always use the [circuit interface].</p>

<pre class="mt-4"><code class="rounded">ctx = {id: 1, params: {text: "Hydrate!"}}

signal, (ctx, flow_options) = A::Upsert.([ctx, {}])
</code></pre>

<p class="mt-6">The <code class="text-purple">ctx</code> will be whatever the most recently executed task returned, and hopefully contain what you’re expecting.</p>

<pre class="mt-4"><code class="rounded"># FIXME
</code></pre>

<p class="mt-6">After this brief introduction, you should check out how [nesting] of activities will help you, what [operations] are, and what awesome debugging tools such as [tracing] we provide.</p>

<p class="mt-6"><code class="text-purple">:activity</code> is guaranteed to match the currently invoked activity</p>

<h2 id="activity-strategy" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Strategy</h2>

<h3 id="activity-strategy-path" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Path</h3>

<p class="mt-6">The simplest strategy is <code class="text-purple">Path</code>, which does nothing but connecting each task’s <code class="text-purple">:success</code> output to the following task.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  step :validate
  step :create
  # ...
end
</code></pre>

<p class="mt-6">Without any additional DSL options, this results in a straight path.</p>

<p class="mt-6"><img src="/assets/path-0aed40fb9a46627199f6e1f62e188fbbc499f35ec2460621fb7b5da5b981bcd4.webp" /></p>

<p class="mt-6">In turn, this means that only <code class="text-purple">true</code> return values in your tasks will work. The DSL will, per default, wrap every task with the <code class="text-purple">Binary</code> interface, meaning returning <code class="text-purple">true</code> will result in <code class="text-purple">Activity::Right</code>, and false in <code class="text-purple">Activity::Left</code>. Currently, only <code class="text-purple">Right</code> signals are wired up.</p>

<h4 id="activity-strategy-path-output" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Path / Output</h4>

<p class="mt-6">You may add as many outputs to a task as you need. The DSL provides the <code class="text-purple">Output()</code> helper to do so.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create
  # ...
end
</code></pre>

<p class="mt-6">The <code class="text-purple">Path</code> strategy only maintains the <code class="text-purple">:success</code>/<code class="text-purple">Activity::Right</code> semantic/signal combination. Any other combination you need to define explicitly using <code class="text-purple">Output(signal, semantic)</code>.</p>

<h4 id="activity-strategy-path-end" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Path / End</h4>

<p class="mt-6">The <code class="text-purple">End()</code> helper allows creating a new end event labelled with the specified semantic.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create
  # ...
end
</code></pre>

<p class="mt-6">This will result in the following circuit.</p>

<p class="mt-6"><img src="/assets/path-end-398f4848ff11f05bd02e94722e57633dbe57db2eb3514d1f53413001bfbcb962.webp" /></p>

<p class="mt-6">The <code class="text-purple">validate</code> task now has a <code class="text-purple">success</code> and a <code class="text-purple">failure</code> output. Since it’s wrapped using <code class="text-purple">Binary</code> it may return <code class="text-purple">true</code> or <code class="text-purple">false</code> to dictate the used output (or <code class="text-purple">Activity::Right</code>/<code class="text-purple">Activity::Left</code> since it’s the [task interface]).</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  # ...
  def validate(ctx, params:, **)
    ctx[:input] = Form.validate(params) # true/false
  end

  def create(ctx, input:, **)
    Memo.create(input)
  end
end
</code></pre>

<p class="mt-6">The activity will halt on the <code class="text-purple">:invalid</code>-labelled end if <code class="text-purple">validate</code> was falsey.</p>

<pre class="mt-4"><code class="rounded">ctx = {params: nil}
signal, (ctx, flow_options) = Memo::Create.([ctx, {}])

puts signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:invalid&gt;
</code></pre>

<h4 id="activity-strategy-path-multiple-references" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Path / Multiple References</h4>

<p class="mt-6">Note that repeatedly using the same semantic (<code class="text-purple">End(:semantic)</code>) will reference the same end event.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create,   Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  # ...
end
</code></pre>

<p class="mt-6">Since we’re adding a <code class="text-purple">:failure</code> output, <code class="text-purple">create</code> now has two outgoing connections.</p>

<p class="mt-6"><img src="/assets/double-end-3d548f9ffc7949edfb45d9037cafacc7313319c399b3c0d6213e8f9d870a8b0e.webp" /></p>

<h3 id="activity-strategy-railway" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Railway</h3>

<p class="mt-6">The <a href="http://fsharpforfunandprofit.com/rop/"><code class="text-purple">Railway</code> pattern</a> is used for “automatic” error handling. You arrange your actual chain of logic on the “success” track, if a problem occurs, the processing jumps to the parallel “failure” track, skipping the rest of the tasks on the success track.</p>

<p class="mt-6">Once on the failure track, it stays there (unless you instruct not to do so!).</p>

<p class="mt-6"><img src="/assets/railway-648894f7ecfbcc0f19237f1e4580b0aa552daf07f626311c86e85cf95b21994d.webp" /></p>

<p class="mt-6">Three possible execution paths this activity might take.</p>

<ul>
  <li>No errors: First <code class="text-purple">validate</code>, then <code class="text-purple">create</code>, then ends in <code class="text-purple">End.success</code>. The activity was successful.</li>
  <li>Validation error: First <code class="text-purple">validate</code>, which returns a <code class="text-purple">Left</code> (failure) signal, leading to <code class="text-purple">log_error</code>, then <code class="text-purple">End.failure</code>.</li>
  <li>Creation error: First <code class="text-purple">validate</code>, then <code class="text-purple">create</code>, which deviates to the failure track, leading to <code class="text-purple">End.failure</code>. Note this doesn’t hit the logging error handler due to the sequence order.</li>
</ul>

<p class="mt-6">To place tasks on the failure track, use <code class="text-purple">#fail</code>. Note that the order of tasks corresponds to the order in the Railway.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error
  step :create
  # ...
end
</code></pre>

<p class="mt-6">Obviously, you may use as many tasks as you need on both tracks. There are no limitations.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Historically, the success path is called "right" whereas the error handling track is "left". The signals `Right` and `Left` in Trailblazer are still named following this convention.

</p>
</div>

<h4 id="activity-strategy-railway-wiring" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Railway / Wiring</h4>

<p class="mt-6">All wiring features apply to <code class="text-purple">Railway</code>. You can rewire, add or remove connections as you please.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error
  step :create, Output(:failure) =&gt; End(:db_error)
  # ...
end
</code></pre>

<p class="mt-6">Railway automatically connects a task’s <code class="text-purple">success</code> output to the next possible task available on the success track. Vice-verse, the <code class="text-purple">failure</code> output is connected the the new possible task on the failure path.</p>

<p class="mt-6">Here, <code class="text-purple">create</code>’s failure output is reconnected.</p>

<p class="mt-6"><img src="/assets/railway-wire-06fe57a60914fbfa6cbc952f77e9087d7eee177bbe19e30c3499b123b631fc67.webp" /></p>

<h4 id="activity-strategy-railway-fail" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Railway / Fail</h4>

<p class="mt-6">DSL’s <code class="text-purple">#fail</code> method allows to place tasks on the failure track.</p>

<p class="mt-6">Such error handlers are still wrapped using <code class="text-purple">Binary</code>. In other words, they can still return a <code class="text-purple">Right</code> or <code class="text-purple">Left</code> signal. However, per default, both outputs are connected to the next task on the failure track.</p>

<p class="mt-6">You may rewire or add outputs on failure tasks, too.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error, Output(:success) =&gt; Track(:success)
  step :create
  # ...
end
</code></pre>

<p class="mt-6">For instance, it’s possible to jump back to the success path if <code class="text-purple">log_error</code> decides to do so.</p>

<p class="mt-6"><img src="/assets/railway-fail-7a397796a06aec011eb69b973a0f623cca78dfe561b8e4f4c3725d233d14d320.webp" /></p>

<p class="mt-6">The return value of <code class="text-purple">log_error</code> now does matter.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  # ...

  def log_error(_ctx, logger:, params:, **)
    logger.error("wrong params: #{params.inspect}")

    fixable?(params) ? true : false # or Activity::Right : Activity::Left
  end
end
</code></pre>

<h4 id="activity-strategy-railway-pass" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Railway / Pass</h4>

<p class="mt-6">If the return value of a “right” task shouldn’t matter, use <code class="text-purple">#pass</code>.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :validate
  fail :log_error
  pass :create
  # ...
end
</code></pre>

<p class="mt-6">Regardless of <code class="text-purple">create</code>’s return value, it will always flow to the next success task.</p>

<p class="mt-6"><img src="/assets/railway-pass-03b3dca30a09e14eef9692bad4ec7d41d2902290a135029c7a51faaaa7733d53.webp" /></p>

<p class="mt-6">Both outputs are connected to the following task on the success path (or, in this case, the success end).</p>

<h4 id="activity-strategy-railway-left" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Railway / Left</h4>
<p class="mt-6"><a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear" class="pink"><i class="fa fa-gem" aria-hidden="true"></i> trailblazer-activity-dsl-linear 1.2.2</a></p>

<p class="mt-6">To avoid syntax problems with several editors, <code class="text-purple">#fail</code> is also aliased as <code class="text-purple">#left</code>.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :validate
  left :log_error
  # ...
end
</code></pre>

<p class="mt-6">The signature and accepted arguments are identical to <code class="text-purple">#fail</code>.</p>

<h4 id="activity-strategy-railway-notes" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Railway / Notes</h4>

<p class="mt-6">FIXME</p>

<ul>
  <li>Using <code class="text-purple">Railway</code>, tasks always get two outputs assigned: <code class="text-purple">:success/Right</code> and <code class="text-purple">:failure/Left</code>.</li>
</ul>

<h3 id="activity-strategy-fasttrack" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">FastTrack</h3>

<p class="mt-6">Based on the <code class="text-purple">Railway</code> strategy, the <code class="text-purple">FastTrack</code> pattern allows to “short-circuit” tasks and leave the circuit at specified events.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
The infamous `Trailblazer::Operation` is a thin public API around `Activity::FastTrack`.

</p>
</div>

<h4 id="activity-strategy-fasttrack-passfast" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">FastTrack / PassFast</h4>

<p class="mt-6">The <code class="text-purple">:pass_fast</code> option wires the <code class="text-purple">:success</code> output straight to the new <code class="text-purple">pass_fast</code> end.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::FastTrack
  step :validate, pass_fast: true
  fail :log_error
  step :create
  # ...
end
</code></pre>

<p class="mt-6">If <code class="text-purple">validate</code> returns a true value, it will skip the remaining tasks on the success track and end in <code class="text-purple">End.pass_fast</code>.</p>

<p class="mt-6"><img src="/assets/ft-passfast-08a96ee6f5b50759cd497096b93f8fd4ffd82f44beb880ca76b738ee6214d0a5.webp" /></p>

<p class="mt-6">Note that in the example, the <code class="text-purple">create</code> task not accessable anymore.</p>

<h4 id="activity-strategy-fasttrack-failfast" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">FastTrack / FailFast</h4>

<p class="mt-6">The counter-part for <code class="text-purple">:pass_fast</code> is <code class="text-purple">:fail_fast</code>.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::FastTrack
  step :validate, fail_fast: true
  fail :log_error
  step :create
  # ...
end
</code></pre>

<p class="mt-6">A falsey return value from <code class="text-purple">#validate</code> will deviate the flow and go straight to <code class="text-purple">End.fail_fast</code>.</p>

<p class="mt-6"><img src="/assets/ft-failfast-9f0d534212f9a8f674dd12653b77d6520da104f79ecef57d650889eda0139317.webp" /></p>

<p class="mt-6">Again, this specific example renders the <code class="text-purple">log_errors</code> task unreachable.</p>

<h4 id="activity-strategy-fasttrack-fasttrack" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">FastTrack / FastTrack</h4>

<p class="mt-6">It’s possible to wire a task to the two FastTrack ends <code class="text-purple">End.fail_fast</code> and <code class="text-purple">End.pass_fast</code> in addition to the normal Railway wiring.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::FastTrack
  step :validate, fast_track: true
  fail :log_error
  step :create

  def validate(ctx, params:, **)
    begin
      ctx[:input] = Form.validate(params) # true/false
    rescue
      return Trailblazer::Activity::FastTrack::FailFast # signal
    end

    ctx[:input] # true/false
  end

  # ...
end
</code></pre>

<p class="mt-6">The <code class="text-purple">validate</code> task now has four outputs. You can instruct the two new FastTrack outputs by returning either <code class="text-purple">Trailblazer::Activity::FastTrack::FailFast</code> or <code class="text-purple">Trailblazer::Activity::FastTrack::PassFast</code> (see also [returning signals]).</p>

<p class="mt-6">Note that you don’t have to use both outputs.</p>

<p class="mt-6"><img src="/assets/ft-fasttrack-32d9a41399bb45604436dee3e47e17bce3caa437179f493c01f97983c410aefc.webp" /></p>

<p class="mt-6">The standard FastTrack setup allows you to communicate and model up to four states from one task.</p>

<h4 id="activity-strategy-fasttrack-notes" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">FastTrack / Notes</h4>

<p class="mt-6">FIXME</p>

<ul>
  <li>All options (<code class="text-purple">:pass_fast</code>, <code class="text-purple">:fail_fast</code> and <code class="text-purple">:fast_track</code>) may be used with <code class="text-purple">step</code>, <code class="text-purple">pass</code> or <code class="text-purple">fail</code>. If in doubt, [render the circuit].</li>
  <li><code class="text-purple">:pass_fast</code> and <code class="text-purple">:fail_fast</code> can be used in combination.</li>
</ul>

<h2 id="activity-wiring-api" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Wiring API</h2>

<p class="mt-6">You can use the wiring API to model more complicated flows in activities.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
The wiring API is implemented in the [`trailblazer-activity-dsl-linear` gem].

Feel invited to write your own DSL using our [low-level mechanics], or if your activities get too complex, please use the [visual editor].

</p>
</div>

<p class="mt-6">In addition to your friends <code class="text-purple">step</code>, <code class="text-purple">pass</code> and <code class="text-purple">fail</code>, the DSL provides helpers to fine-tune your wiring.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard
end
</code></pre>

<p class="mt-6">By default, and without additional helpers used, the DSL will connect every <code class="text-purple">step</code> task’s two outputs to the two respective tracks of a “railway”.</p>

<p class="mt-6"><img src="/assets/wire-output-91f33ce06da52e3c0670373be8e40700cbac643873ba34ee8732c9a7fa5b5517.webp" /></p>

<h3 id="activity-wiring-api-output-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Output()</h3>

<p class="mt-6">The <code class="text-purple">Output()</code> method helps to rewire one or more specific outputs of a task, or to add outputs.</p>

<p class="mt-6">To understand this helper, you should understand that every <code class="text-purple">step</code> invocation calls <code class="text-purple">Output()</code> for you behind the scenes. The following DSL use is identical to the one [above].</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider,
    Output(Trailblazer::Activity::Left, :failure) =&gt; Track(:failure),
    Output(Trailblazer::Activity::Right, :success) =&gt; Track(:success)
  step :charge_creditcard

end
</code></pre>

<p class="mt-6">We’re adding two outputs here, provide the <em>signal</em> as the first and the <em>semantic</em> as the second parameter to <code class="text-purple">Output()</code> and then connect them to a track.</p>

<h4 id="activity-wiring-api-output-implicit-signal" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Output() / Implicit signal</h4>

<p class="mt-6">Trailblazer has two outputs predefined. As you might’ve guessed, the <code class="text-purple">:failure</code> and <code class="text-purple">:success</code> outputs are a convention. This allows to <strong>omit the signal</strong> when referencing an existing output.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider, Output(:failure) =&gt; Track(:failure)
  step :charge_creditcard
end
</code></pre>

<p class="mt-6">As the DSL knows the <code class="text-purple">:failure</code> output, it will reconnect it accordingly while keeping the signal.</p>

<h4 id="activity-wiring-api-output-adding-outputs" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Output() / Adding outputs</h4>

<p class="mt-6">When specifying a new semantic to <code class="text-purple">Output()</code>, you are adding an output to the task. This is why you must also pass a signal as the first argument.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Since a particular output is triggered by a particular signal, note that each output must be configured with a **unique signal** per activity.

</p>
</div>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  UsePaypal = Class.new(Trailblazer::Activity::Signal)

  step :find_provider, Output(UsePaypal, :paypal) =&gt; Track(:paypal)
  step :charge_creditcard
end
</code></pre>

<p class="mt-6"><img src="/assets/wire-output-add-4a2a580fef338567b169abbc18a31c8706cc0282d872c638b0e7ad1bd44efefa.webp" /></p>

<p class="mt-6">The <code class="text-purple">find_provider</code> task now has three possible outcomes that can be triggered by returning either <code class="text-purple">Right</code>, <code class="text-purple">Left</code>, or <code class="text-purple">UsePaypal</code>.</p>

<h3 id="activity-wiring-api-end-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">End()</h3>

<p class="mt-6">Use <code class="text-purple">End()</code> to connect outputs to an existing end, or create a new end.</p>

<p class="mt-6">You may reference existing ends by their semantic.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard, Output(:failure) =&gt; End(:success)
end
</code></pre>

<p class="mt-6">This reconnects both outputs to the same end, always ending in a - desirable, yet unrealistic - successful state.</p>

<p class="mt-6"><img src="/assets/wire-output-end-fd521cb4edb13ee717b1ec7be6e4d8f4ce5b7553c58597061afc9ba6c91e476a.webp" /></p>

<h4 id="activity-wiring-api-end-adding-ends" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">End() / Adding ends</h4>

<p class="mt-6">Providing a new semantic to the <code class="text-purple">End()</code> function will create a new end event.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard, Output(:failure) =&gt; End(:declined)
end
</code></pre>

<p class="mt-6">Adding ends to an activity is a beautiful way to communicate more than two outcomes to the outer world without having to use a state field in the <code class="text-purple">ctx</code>. It also allows wiring those outcomes to different tracks in the container activity. [See nesting]</p>

<p class="mt-6"><img src="/assets/wire-output-endadd-6e7a87f2edb1e2e69f8310d4c2dc798ee33e56a1df98efb897f4167e3769888c.webp" /></p>

<p class="mt-6">This activity now maintains three end events. The path to the <code class="text-purple">declined</code> end is taken from the task’s <code class="text-purple">failure</code> output.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Successive uses of the same `End(:semantic)` will all connect to the same end.

</p>
</div>

<h3 id="activity-wiring-api-id-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Id()</h3>

<p class="mt-6">An output can be connected to a particular task by using <code class="text-purple">Id()</code>.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider
  step :charge_creditcard, Output(:failure) =&gt; Id(:find_provider)
end
</code></pre>

<p class="mt-6">This connects the <code class="text-purple">failure</code> output to the previous task, which might create an infinity loop and waste your computing time - it is solely here for demonstrational purposes.</p>

<h3 id="activity-wiring-api-track-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Track()</h3>

<p class="mt-6">The <code class="text-purple">Track()</code> function will snap the output to the next task that is “magnetic to” the track’s semantic.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider, Output(:success) =&gt; Track(:failure)
  step :charge_creditcard
  fail :notify
end
</code></pre>

<p class="mt-6">Since <code class="text-purple">notify</code> sits on the “failure” track and hence is “magnetic to” <code class="text-purple">:failure</code>, <code class="text-purple">find_provider</code> will be connected to it.</p>

<p class="mt-6">Using <code class="text-purple">Track()</code> with a new track semantic only makes sense when using the [<code class="text-purple">:magnetic_to</code> option] on other tasks.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Use [Path()] if you want to avoid `Track()` and `:magnetic_to` - this helper does nothing but providing those values to your convenience.

</p>
</div>

<h3 id="activity-wiring-api-terminus" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Terminus</h3>

<p class="mt-6"><a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear" class="pink"><i class="fa fa-gem" aria-hidden="true"></i> trailblazer-activity-dsl-linear 1.0.0</a></p>

<p class="mt-6">In addition to the strategy’s termini, you can add your own end events using <code class="text-purple">#terminus</code>. This is an important design tool helping you to communicate outcomes other than “success” or “failure” to the outer world (in a <code class="text-purple">Railway</code> activity).</p>

<pre class="mt-4"><code class="rounded">module Payment::Operation
  class Create &lt; Trailblazer::Activity::Railway
    step :find_provider

    terminus :provider_invalid # , id: "End.provider_invalid", magnetic_to: :provider_invalid
    # ...
  end
end
</code></pre>

<p class="mt-6">The above code adds a new terminus named <code class="text-purple">End.provider_invalid</code> to the activity.</p>

<p class="mt-6"><img src="/assets/wiring-terminus-dashed-19d851d50f1dad1a04a17d9d153fc14a06efef5e941db9807051d7a70cd0c5ff.png" /></p>

<p class="mt-6">As visible, this terminus is not connected to anything as its <code class="text-purple">magnetic_to</code> property is set to <code class="text-purple">:provider_invalid</code>.</p>

<p class="mt-6">You could now connect <code class="text-purple">find_provider</code>’s failure output to the new terminus by using the <code class="text-purple">Track()</code> helper.</p>

<pre class="mt-4"><code class="rounded">module Payment::Operation
  class Create &lt; Trailblazer::Activity::Railway
    step :find_provider,
      # connect {failure} to the next element that is magnetic_to {:provider_invalid}.
      Output(:failure) =&gt; Track(:provider_invalid)

    terminus :provider_invalid
    # ...
  end
end
</code></pre>

<p class="mt-6">The failure output will be connected to the next following element that is magnetic_to <code class="text-purple">:provider_invalid</code>, which is the new terminus we created.</p>

<p class="mt-6"><img src="/assets/wiring-terminus-track-f94047e9e766080de0ae7639ed42013bfb2e56e2dfd07a1e83bef12e51608ffe.png" /></p>

<p class="mt-6">Invoking this activity with an unsolicited provider will stop on the newly added terminus.</p>

<pre class="mt-4"><code class="rounded">signal, (ctx, _) = Payment::Operation::Create.(provider: "bla-unknown")
puts signal.to_h[:semantic] #=&gt; :provider_invalid
</code></pre>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
The default semantic is `:provider_invalid`. Note that the following options `:id` and `:magnetic_to` can be passed to `#terminus`:

* `:id`
* `:magnetic_to`
* `:task` which has to be a subclass of `Trailblazer::Activity::End`.

</p>
</div>


<h3 id="activity-wiring-api-path-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Path()</h3>

<p class="mt-6"><a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear" class="pink"><i class="fa fa-gem" aria-hidden="true"></i> trailblazer-activity-dsl-linear 1.2.0</a></p>

<p class="mt-6">For branching out a separate path in an activity, use the <code class="text-purple">Path()</code> macro. It’s a convenient, simple way to declare alternative routes, even if you could do everything it does manually.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Charge &lt; Trailblazer::Activity::Railway
    # ...
    step :validate
    step :decide_type, Output(:failure) =&gt; Path(terminus: :with_cc) do
      step :authorize
      step :charge
    end
    step :direct_debit
  end
end
</code></pre>

<p class="mt-6">If <code class="text-purple">#decide_type</code> returns false, the path will be executed and terminate on the new terminus <code class="text-purple">End.with_cc</code> because of the <code class="text-purple">:terminus</code> option.</p>

<p class="mt-6"><img src="/assets/path-cc-ac6fba7ad1d50cf000b756c49cc23df18b26abb0536b2b838839d607f0251a84.png" /></p>

<p class="mt-6">Note that you don’t necessarily have to reuse the <code class="text-purple">:failure</code> output in order to branch out a new path. You might as well use an <a href="#activity-wiring-api-path-railway">additional signal</a>, or any other predefined output of the task.</p>

<h4 id="activity-wiring-api-path-join" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Path() / Join</h4>

<p class="mt-6">If you want the path to reconnect and join the activity at some point, use the <code class="text-purple">:connect_to</code> option.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Charge &lt; Trailblazer::Activity::Railway
    # ...
    step :validate
    step :decide_type, Output(:failure) =&gt; Path(connect_to: Id(:finalize)) do
      step :authorize
      step :charge
    end
    step :direct_debit
    step :finalize
  end
end
</code></pre>

<p class="mt-6">There won’t be an additional terminus created.</p>

<p class="mt-6"><img src="/assets/path-join-3adbb95f6e529aff8230f80e5f3ee33d031c6fdf20620faa96d87fe1178d366c.png" /></p>

<h4 id="activity-wiring-api-path-railway" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Path() / Railway</h4>

<p class="mt-6">You can use <code class="text-purple">Path()</code> in any Trailblazer strategy, for example in <code class="text-purple">Railway</code>.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Charge &lt; Trailblazer::Activity::Railway
    MySignal = Class.new(Trailblazer::Activity::Signal)
    # ...
    step :validate
    step :decide_type, Output(MySignal, :credit_card) =&gt; Path(connect_to: Id(:finalize)) do
      step :authorize
      step :charge
    end
    step :direct_debit
    step :finalize
  end
end
</code></pre>

<p class="mt-6">In this example, we add a third output to <code class="text-purple">#decide_type</code> to handle the credit card payment scenario (you could also “override” or re-configure the existing <code class="text-purple">:failure</code> or <code class="text-purple">:success</code> outputs).</p>

<p class="mt-6"><img src="/assets/path-railway-71d49663e4c9b388e17ad0c985be26b2246f63d84aea8c079421d20df5257e85.png" /></p>

<p class="mt-6">Only when <code class="text-purple">decide_type</code> returns <code class="text-purple">MySignal</code>, the new path alternative is taken.</p>

<pre class="mt-4"><code class="rounded">def decide_type(ctx, model:, **)
  if model.is_a?(CreditCard)
    return MySignal # go the Path() way!
  elsif model.is_a?(DebitCard)
    return true
  else
    return false
  end
end
</code></pre>

<p class="mt-6"><code class="text-purple">Output()</code> in combination with <code class="text-purple">Path()</code> allows for a simple modeling of alternative routes.</p>

<!-- OLD link https://trailblazer.to/2.1/docs/activity.html#activity-wiring-api-path-end_task-end_id-deprecation -->
<h4 id="activity-wiring-api-path-end_task-end_id-deprecation" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Path() / End_task/End_id Deprecation</h4>

<p class="mt-6">In older versions before <code class="text-purple">trailblazer-activity-dsl-linear-1.2.0</code>, connecting the <code class="text-purple">Path()</code> to a separate terminus required you to pass two  options <code class="text-purple">:end_task</code> and <code class="text-purple">:end_id</code>.</p>

<pre class="mt-4"><code class="rounded">
Output(...) =&gt; Path(end_task: Activity::End.new(semantic: :valid), end_id: "End.valid") do
  # ...
end</code></pre>

<p class="mt-6">This is now simplified (and more consistent) by introducing the <code class="text-purple">:terminus</code> option.</p>

<pre class="mt-4"><code class="rounded">
Output(...) =&gt; Path(terminus: :valid) do
  # ...
end</code></pre>

<p class="mt-6">If you haven’t updated your code you will see a deprecation warning.</p>

<pre class="mt-4"><code class="rounded">
[Trailblazer] &lt;file.rb&gt; Using `:end_task` and `:end_id` in Path() is deprecated, use `:terminus` instead.
  Please refer to https://trailblazer.to/2.1/docs/activity.html#activity-wiring-api-path-end_task-end_id-deprecation</code></pre>

<h3 id="activity-wiring-api-subprocess" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Subprocess</h3>

<p class="mt-6">While you could nest an activity into another manually, the <code class="text-purple">Subprocess</code> macro will come in handy.</p>

<p class="mt-6">Consider the following nested activity.</p>

<pre class="mt-4"><code class="rounded">class Memo::Validate &lt; Trailblazer::Activity::Railway
  step :check_params
  step :check_attributes
  # ...
end
</code></pre>

<p class="mt-6">Use <code class="text-purple">Subprocess</code> to nest it into the <code class="text-purple">Create</code> activity.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Subprocess(Memo::Validate)
  step :save
  # ...
  # ...
</code></pre>

<p class="mt-6">The macro automatically wires all of <code class="text-purple">Validate</code>’s ends to the known counter-part tracks.</p>

<p class="mt-6"><img src="/assets/nesting-f9455ca004cfeb4e67d8b53a2ce928b5f5a287e77235ee03f65423fa8429d58f.webp" /></p>

<p class="mt-6">The <code class="text-purple">Subprocess</code> macro will go through all outputs of the nested activity, query their semantics and search for tracks with the same semantic.</p>

<p class="mt-6">Note that the failure track starting from <code class="text-purple">create_model</code> will skip the nested activity, just as if it was simple task.</p>

<h4 id="activity-wiring-api-subprocess-wiring" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Subprocess / Wiring</h4>

<p class="mt-6">You can use the familiar DSL to reconnect ends.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Subprocess(Memo::Validate), Output(:failure) =&gt; Track(:success)
  step :save
  # ...
end
</code></pre>

<p class="mt-6">The nested’s <code class="text-purple">failure</code> output now goes to the outer <code class="text-purple">success</code> track.</p>

<p class="mt-6"><img src="/assets/nesting-reconnect-e7edbdb76b17cf2459147856bc3ff66f6c8a09e917fcaeba3d7341dc0dea6842.webp" /></p>

<p class="mt-6">In this example, regardless of nested’s outcome, it will always be interpreted as a successful invocation.</p>

<h4 id="activity-wiring-api-subprocess-end" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Subprocess / End</h4>

<p class="mt-6">A nested activity doesn’t have to have two ends, only.</p>

<pre class="mt-4"><code class="rounded">class Memo::Validate &lt; Trailblazer::Activity::Railway
  step :check_params, Output(:failure) =&gt; End(:invalid_params)
  step :check_attributes
  # ...
end
</code></pre>

<p class="mt-6"><code class="text-purple">Subprocess</code> will try to match the nested ends’ semantics to the tracks it knows. You may wire custom ends using <code class="text-purple">Output</code>.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Subprocess(Memo::Validate), Output(:invalid_params) =&gt; Track(:failure)
  step :save
  # ...
end
</code></pre>

<p class="mt-6">The new special end is now wired to the <code class="text-purple">failure</code> track of the containing activity.</p>

<p class="mt-6"><img src="/assets/nesting-end-cb586ffe0c8e1bffb7102027ffc525cba41eb2293252170ac9b48742718dee2e.webp" /></p>

<p class="mt-6">There will be an exception thrown if you don’t connect unknown ends.</p>


<h2 id="activity-dsl-options" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">DSL Options</h2>

<p class="mt-6"><code class="text-purple">#step</code> and friends accept a bunch of options in order to insert a task at a specific location, add pre-defined connections and outputs, or even configure its taskWrap.
<!--
  outputs
  connections
  magnetic_to
 --></p>

<h3 id="activity-dsl-options-magnetic_to" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">magnetic_to</h3>

<p class="mt-6">In combination with [<code class="text-purple">Track()</code>], the <code class="text-purple">:magnetic_to</code> option allows for a neat way to spawn custom tracks outside of the conventional Railway or FastTrack schema.</p>

<pre class="mt-4"><code class="rounded">class Execute &lt; Trailblazer::Activity::Railway
  step :find_provider, Output(:failure) =&gt; Track(:paypal)
  step :charge_creditcard
  step :charge_paypal, magnetic_to: :paypal
end
</code></pre>

<p class="mt-6">The <code class="text-purple">failure</code> output of the <code class="text-purple">find_provider</code> task will now snap to the next task being <code class="text-purple">:magnetic_to</code> its semantic - which obviously is the <code class="text-purple">charge_paypal</code> task.</p>

<p class="mt-6">When creating a new branch (or path) in this way, it’s a matter of repeating the use of <code class="text-purple">Track()</code> and <code class="text-purple">:magnetic_to</code> to add more tasks to the branch.</p>

<h3 id="activity-dsl-options-extensions" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">extensions</h3>

<h3 id="activity-dsl-options-inherit" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Inherit</h3>

<h3 id="activity-dsl-options-sequence-options" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Sequence Options</h3>

<p class="mt-6">In addition to wiring options, there are a handful of other options known as <em>sequence options</em>. They configure where a task goes when inserted, and helps with introspection and tracing.</p>

<h4 id="activity-dsl-options-sequence-options-id" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Sequence Options / id</h4>

<p class="mt-6">The DSL will provide default names for tasks.
You can name explicitely using the <code class="text-purple">:id</code> option.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Path
  step :create_model
  step :validate
  step :save, id: :save_the_world
  # ...
end
</code></pre>

<p class="mt-6">The IDs are as follows.</p>

<pre class="mt-4"><code class="rounded">Trailblazer::Developer.railway(Memo::Create)
#=&gt; [&gt;create_model,&gt;validate,&gt;save_the_world]
</code></pre>

<p class="mt-6">This is advisable when planning to override a step via a module or inheritance or when reconnecting it. Naming also shows up in tracing and introspection. Defaults names are given to steps without the <code class="text-purple">:id</code> options, but these might be awkward sometimes.</p>

<h4 id="activity-dsl-options-sequence-options-delete" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Sequence Options / Delete</h4>

<p class="mt-6">When it’s necessary to remove a task, you can use <code class="text-purple">:delete</code>.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create::Admin &lt; Memo::Create
  step nil, delete: :validate
end
</code></pre>

<p class="mt-6">The <code class="text-purple">:delete</code> option can be helpful when using modules or inheritance to build concrete operations from base operations. In this example, a very poor one, the <code class="text-purple">validate</code> task gets removed, assuming the <code class="text-purple">Admin</code> won’t need a validation.</p>

<pre class="mt-4"><code class="rounded">Trailblazer::Developer.railway(Memo::Create::Admin)
#=&gt; [&gt;create_model,&gt;save_the_world]
</code></pre>

<p class="mt-6">All steps are inherited, then the deletion is applied, as the introspection shows.</p>

<h4 id="activity-dsl-options-sequence-options-before" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Sequence Options / Before</h4>

<p class="mt-6">To insert a new task before an existing one, for example in a subclass, use <code class="text-purple">:before</code>.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create::Authorized &lt; Memo::Create
  step :policy, before: :create_model
  # ...
end
</code></pre>

<p class="mt-6">The circuit now yields a new <code class="text-purple">policy</code> step before the inherited tasks.</p>

<pre class="mt-4"><code class="rounded">Trailblazer::Developer.railway(Memo::Create::Authorized)
#=&gt; [&gt;policy,&gt;create_model,&gt;validate,&gt;save_the_world]
</code></pre>

<h4 id="activity-dsl-options-sequence-options-after" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Sequence Options / After</h4>

<p class="mt-6">To insert after an existing task, you might have guessed it, use the <code class="text-purple">:after</code> option with the exact same semantics as <code class="text-purple">:before</code>.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create::Logging &lt; Memo::Create
  step :logger, after: :validate
  # ...
end
</code></pre>

<p class="mt-6">The task is inserted after, as the introspection shows.</p>

<pre class="mt-4"><code class="rounded">Trailblazer::Developer.railway(Memo::Create::Logging)
#=&gt; [&gt;create_model,&gt;validate,&gt;logger,&gt;save_the_world]
</code></pre>

<h4 id="activity-dsl-options-sequence-options-replace" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Sequence Options / Replace</h4>

<p class="mt-6">Replacing an existing task is done using <code class="text-purple">:replace</code>.</p>

<pre class="mt-4"><code class="rounded">class Memo::Update &lt; Memo::Create
  step :find_model, replace: :create_model, id: :update_memo
  # ...
end
</code></pre>

<p class="mt-6">Replacing, obviously, only replaces in the applied class, not in the superclass.</p>

<pre class="mt-4"><code class="rounded">Trailblazer::Developer.railway(Memo::Update)
#=&gt; [&gt;update_memo,&gt;validate,&gt;save_the_world]
</code></pre>

<h3 id="activity-dsl-options-patching" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Patching</h3>

<p class="mt-6">Working with <code class="text-purple">Subprocess</code> and nested activities is a great way to encapsulate and create reusable code especially with complex logic. However, it can be a PITA if you want to customize one of those deeply nested components and add, replace or remove a certain step.</p>

<p class="mt-6">Suppose the following 3-level nested activity.</p>

<p class="mt-6"><img width="63%" src="/assets/patch-bcd7630136eb2d8e2fd342cc94be1deb81b17f6313e448548ffd0493425fce74.png" /></p>

<p class="mt-6">The public operation <code class="text-purple">Destroy</code> contains <code class="text-purple">Delete</code> as a nested activity, which itself contains <code class="text-purple">DeleteAssets</code>. In order to customize the latter one and add another step <code class="text-purple">tidy_storage</code>, you’d normally have to subclass all three activities and override steps.</p>

<h4 id="activity-dsl-options-patching-patch" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Patching / Patch</h4>

<p class="mt-6">Using <code class="text-purple">#patch</code>, you can modify nested activities from the uppermost activity and let Trailblazer do the legwork.</p>

<p class="mt-6">As <code class="text-purple">#patch</code> is mostly used when leveraging inheritance we introduce a subclass of <code class="text-purple">Destroy</code> which is called <code class="text-purple">Erase</code> and introduces the <code class="text-purple">#tidy_storage</code> step. As illustrated above, this new step should be inserted in <code class="text-purple">DeleteAssets</code> activity that itself is nested in <code class="text-purple">Delete</code>, which again is one step of <code class="text-purple">Destroy</code>.</p>

<pre class="mt-4"><code class="rounded">class Erase &lt; Destroy # we're inheriting from Song::Operation::Destroy
  # ...
  def self.tidy_storage(ctx, **)
    # delete files from your amazing cloud
  end
  # ...
  # These steps are inherited:
  # step :policy
  # step :find_model
  # step Subprocess(Delete), id: :delete

  extend Trailblazer::Activity::DSL::Linear::Patch::DSL

  # Note the path you pass to #patch.
  patch(:delete, :delete_assets) {
    step Erase.method(:tidy_storage), after: :rm_images
  }
end
</code></pre>

<p class="mt-6">The patching logic accepts a path to the particular activity that you want to modify.</p>

<pre class="mt-4"><code class="rounded">
patch(:delete, :delete_assets) { ... }</code></pre>

<p class="mt-6">The provided block is executed within that targeted activity and executed as if you’d extend that class. However, the entire modification will only change <code class="text-purple">Erase</code>, all other traversed activities are copied and then modified, leaving the original implemenation unchanged.</p>

<p class="mt-6"><img src="/assets/patch-trace-9c20114ea59171f3d46345361ee0ea9522a621429f22f9f64a7723c5937158b2.png" /></p>

<p class="mt-6">The <code class="text-purple">#patch</code> method is perfect when using inheritance to first copy over behavior and control flow, and then fine-tune it for the specific use case.</p>

<h4 id="activity-dsl-options-patching-patch-option" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Patching / Patch Option</h4>

<p class="mt-6">If you’re not using inheritance and want to tweak a nested activity ad-hoc the <code class="text-purple">Subprocess()</code> helper accepts a <code class="text-purple">:patch</code> option.</p>

<pre class="mt-4"><code class="rounded">class Destroy &lt; Trailblazer::Activity::Railway
  def self.tidy_storage(ctx, **)
    # delete files from your amazing cloud
    true
  end
  # ...
  step :policy
  step :find_model
  step Subprocess(Delete,
    patch: {
      [:delete_assets] =&gt; -&gt; { step Destroy.method(:tidy_storage), before: :rm_uploads }
    }
  )
end
</code></pre>

<p class="mt-6">This works just like the <code class="text-purple">#patch</code> function but returns the patched activity.</p>

<p class="mt-6"><code class="text-purple">Subprocess()</code> accepts the <code class="text-purple">:patch</code> option which consists of a hash of the path to the customized activity, and its patch.</p>

<p class="mt-6">This will result in an identical operation as in the above example with <code class="text-purple">#patch</code>. However, <code class="text-purple">Delete</code> is now the operation containing the customization, not a new class <code class="text-purple">Erase</code>.</p>

<p class="mt-6">Patching can be also done at the top-level activity by passing  <code class="text-purple">:patch</code> as a block (Take <code class="text-purple">Delete</code> from above example).</p>

<pre class="mt-4"><code class="rounded">step Subprocess(
  Delete,
  patch: -&gt; { step Destroy.method(:tidy_storage), before: :delete_model }
), id: :delete
</code></pre>


<h2 id="activity-variable-mapping" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Variable Mapping</h2>

<p class="mt-6"><a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear" class="pink"><i class="fa fa-gem" aria-hidden="true"></i> trailblazer-activity-dsl-linear 1.2.0</a></p>

<p class="mt-6">Since TRB 2.1 it is possible to define the input and output variables for each step. This is called <em>variable mapping</em>, or I/O in short. It provides an interface to define what variable go in and come out of a task, enabling you to limit what steps “see” and what “output” they can add to the context.</p>

<p class="mt-6">It’s one of the most frequently used features in Trailblazer.</p>

<h3 id="activity-variable-mapping-overview" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Overview</h3>

<p class="mt-6">Imagine a complex application where policies are protecting your operation code from unsolicited access. This code component - the policy - sits as a step in every business operation and decides whether or not the current user is permitted to execute this very operation.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create # an imaginary policy step.
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">The <code class="text-purple">Policy::Create</code> implementation is a simple callable class following the <a href="#activity-internals-step-interface">step interface</a>.</p>

<pre class="mt-4"><code class="rounded">module Policy
  # Explicit policy, not ideal as it results in a lot of code.
  class Create
    def self.call(ctx, model:, user:, **)
      decision = ApplicationPolicy.can?(model, user, :create) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p class="mt-6">Note that it requires two variables <code class="text-purple">:model</code> and <code class="text-purple">:user</code> from the ctx. For whatever reasons, the author of this class dictated that the “current user” must be passed named <code class="text-purple">:user</code>, not, as it’s a convention in Trailblazer, named <code class="text-purple">:current_user</code>.</p>

<p class="mt-6">Last, depending on the policy decision, the step code returns true or false.</p>

<p class="mt-6">When executing the <code class="text-purple">Create</code> operation using the <code class="text-purple">:current_user</code> variable, an <code class="text-purple">ArgumentError</code> is raised.</p>

<pre class="mt-4"><code class="rounded">result = Trailblazer::Activity.(Song::Activity::Create, current_user: Module)

#=&gt; ArgumentError: missing keyword: :user
</code></pre>

<p class="mt-6">Since the “current user” is handed into the operation as the <code class="text-purple">:current_user</code> variable, and no other step preceding <code class="text-purple">Policy::Create</code> is setting this variable, the step expecting <code class="text-purple">:user</code> crashes.</p>

<p class="mt-6">And this is why we need variable mapping in Trailblazer.</p>

<h3 id="activity-variable-mapping-composable-i-o" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Composable I/o</h3>

<p class="mt-6">Variable mapping (short: i/o) can be done manually, with ugly “helper” steps before or after the respective step, or by using <code class="text-purple">In()</code>, <code class="text-purple">Out()</code> and <code class="text-purple">Inject()</code>. Before these helpers got introduced, we used the <code class="text-purple">:input</code> and <code class="text-purple">:output</code> option - both works, the latter one coming with several drawbacks.</p>

<p class="mt-6">Helpers can be used multiple times, depending on how complex the incoming or outcoming variables are, forming a pipeline of filters around the actual task.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message]
    # ...
  end
end
</code></pre>

<p class="mt-6">Not only are those input and output pipelines easy to <a href="#activity-variable-mapping-introspect">debug</a>, they also allow to be altered in derived operations, when <a href="#activity-variable-mapping-inheritance">using inheritance</a>, and  work in <a href="#activity-variable-mapping-macro">combination with macros</a>.</p>

<h3 id="activity-variable-mapping-in-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">In()</h3>

<p class="mt-6"><code class="text-purple">In()</code> allows to configure variables going <em>into</em> the step. The helper accepts either a mapping hash, a limiting array or a callable object (often a lambda), to compute variables at runtime.</p>

<p class="mt-6">Be wary that once you <strong>use <code class="text-purple">In()</code> your are white-listing</strong>: only the variables defined in your filters will be passed into the step. All other variables from ctx are invisible in the step.</p>

<h4 id="activity-variable-mapping-in-mapping-hash" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">In() / Mapping hash</h4>

<p class="mt-6">Picking up the example from above, here’s how a mapping hash “translates” the selected variables from the original ctx object to a new ctx, one that is compatible with <code class="text-purple">Policy::Create</code>’s interface.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :create_model
  step Policy::Create,
    In() =&gt; {
      :current_user =&gt; :user, # rename {:current_user} to {:user}
      :model        =&gt; :model # add {:model} to the inner ctx.
    }
  # ...
end
</code></pre>

<p class="mt-6">The <code class="text-purple">In()</code> filter will result in <code class="text-purple">:current_user</code> being renamed to <code class="text-purple">:user</code>. Since the policy step also needs <code class="text-purple">:model</code> we need to mention this variable as well, no renaming happening here. The beauty of I/O: this is only visible to <code class="text-purple">Policy::Create</code>!</p>

<p class="mt-6"><img src="/assets/ctx-in-7d4b12e96d0794df8f525c8f021da2d37834bee7bbfb86fba8698f580e8a77c6.png" /></p>

<p class="mt-6">To instantly see what new ctx is passed into the configured step, you could replace the original policy step with a <code class="text-purple">#show_ctx</code> method.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step :show_ctx,
      In() =&gt; {
        :current_user =&gt; :user, # rename {:current_user} to {:user}
        :model        =&gt; :model # add {:model} to the inner ctx.
      }

    def show_ctx(ctx, **)
      p ctx.to_h
      #=&gt; {:user=&gt;#&lt;User email:...&gt;, :model=&gt;#&lt;Song name=nil&gt;}
    end
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">You should use the mapping hash when variables need to be renamed. If variables need to be added without renaming, a limiting array is your friend.</p>

<h4 id="activity-variable-mapping-in-limiting-array" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">In() / Limiting array</h4>

<p class="mt-6"><code class="text-purple">In()</code> accepts an array, listed variables are passed into the new ctx (whether they exist in the original ctx or not!).</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model]
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">This configuration will lead to the exact same new ctx for <code class="text-purple">Policy::Create</code> as in the <a href="#activity-variable-mapping-in-mapping-hash">example above</a>, producing a new ctx that will look as below.</p>

<pre class="mt-4"><code class="rounded">
#=&gt; {
#     :user  =&gt; #&lt;User email:...&gt;,
#     :model =&gt; #&lt;Song name=nil&gt;}
#   }</code></pre>

<h4 id="activity-variable-mapping-in-callable" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">In() / Callable</h4>

<p class="mt-6">As always, you may implement your own input filter with any callable object [adhering to the step interface])(#activity-internals-step-interface).</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; -&gt;(ctx, **) do
        # only rename {:current_user} if it's there.
        ctx[:current_user].nil? ? {} : {user: ctx[:current_user]}
      end,
      In() =&gt; [:model]
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">Callable <code class="text-purple">In()</code> filters <strong>have to</strong> return a hash. This hash will be merged with the other <code class="text-purple">In()</code> filters and comprise the new ctx.</p>

<p class="mt-6">And again, when the operation is invoked with a <code class="text-purple">:current_user</code>, this will, result in the same new ctx as above.</p>

<pre class="mt-4"><code class="rounded">
#=&gt; {
#     :user  =&gt; #&lt;User email:...&gt;,
#     :model =&gt; #&lt;Song name=nil&gt;}
#   }</code></pre>

<p class="mt-6">However, if <code class="text-purple">:current_user</code> is <code class="text-purple">nil</code>, <code class="text-purple">Policy::Create</code> will raise an exception complaining about the <code class="text-purple">:user</code> keyword missing.</p>

<h4 id="activity-variable-mapping-in-filter-method" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">In() / Filter method</h4>

<p class="mt-6">Following the TRB option standard, an <code class="text-purple">In()</code> filter may even be implemented as an instance method. All you need to do is pass a symbol to <code class="text-purple">In()</code>.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; :input_for_policy, # You can use an {:instance_method}!
      In() =&gt; [:model]

    def input_for_policy(ctx, **)
      # only rename {:current_user} if it's there.
      ctx[:current_user].nil? ? {} : {user: ctx[:current_user]}
    end
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">The method needs to expose a step interface just like any other callable.</p>

<h4 id="activity-variable-mapping-in-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">In() / Keyword arguments</h4>

<p class="mt-6">Both callables and filter methods for <code class="text-purple">In()</code> can receive ctx variables as keyword arguments, making it a convenient access and have Ruby perform a loose existance test automatically.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
                    # vvvvvvvvvvvv keyword arguments rock!
      In() =&gt; -&gt;(ctx, current_user: nil, **) do
        current_user.nil? ? {} : {user: current_user}
      end,
      In() =&gt; [:model]
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">Keep in mind that when not defaulting the keyword argument your filter might crash at runtime when the expected variables were not passed.</p>

<h3 id="activity-variable-mapping-out-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Out()</h3>

<p class="mt-6">Without any output configuration on the exemplary policy step, any variable written to <code class="text-purple">ctx</code> will be automatically set on the outer ctx, passing along internal variabes to the following step.</p>

<p class="mt-6"><img src="/assets/ctx-out-all-d2ddf6c9b6b68d02600517a8a5a3d5ff0adc51fa81b3a8dc67213c51f2d22615.png" /></p>

<p class="mt-6">Here, both <code class="text-purple">:status</code> and <code class="text-purple">:message</code> variables that were written in <code class="text-purple">Policy::Create</code> are passed into the outer ctx. The behavior is identical to the way before you were using i/o.</p>

<p class="mt-6">However, it is often necessary to rename or limit the outgoing variables of a particular step. Especially when using nested operations you probably don’t want the entire nested ctx to be copied into the outer context. This is where output filters enter the stage.</p>

<p class="mt-6">Consider the following updated <code class="text-purple">Policy::Create</code> step.</p>

<pre class="mt-4"><code class="rounded">module Policy
  # Explicit policy, not ideal as it results in a lot of code.
  class Create
    def self.call(ctx, model:, user:, **)
      decision = ApplicationPolicy.can?(model, user, :create) # FIXME: how does pundit/cancan do this exactly?

      if decision.allowed?
        return true
      else
        ctx[:status]  = 422 # we're not interested in this field.
        ctx[:message] = "Command {create} not allowed!"
        return false
      end
    end
  end
end
</code></pre>

<p class="mt-6">Both <code class="text-purple">ctx[:status]</code> and <code class="text-purple">ctx[:message]</code> will be visible in all steps following <code class="text-purple">Policy::Create</code>. This might lead to “misunderstandings” and bugs in more complex applications.</p>

<p class="mt-6">As soon as you use <code class="text-purple">Out()</code>, only variables specified through the filters will be merged with the original (outer) ctx and passed on to the next step.</p>

<h4 id="activity-variable-mapping-out-limiting-array" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Out() / Limiting array</h4>

<p class="mt-6">In order to limit variables added to the outer ctx, <code class="text-purple">Out()</code> accepts an array similar to <code class="text-purple">In()</code>. Consider this as a whitelisting to specify exposed variables.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message]
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">This single <code class="text-purple">Out()</code> usage will result in only the <code class="text-purple">:message</code> variable being written to the outer ctx that is passed on. The <code class="text-purple">:status</code> variable is discarded.</p>

<p class="mt-6"><img src="/assets/ctx-out-5f24f390da6bdab0bdfd5bb752fe3312a47941a0736c585e2e3c164c5d73f744.png" /></p>

<p class="mt-6">You may pass any number of variables in the limiting array.</p>

<h4 id="activity-variable-mapping-out-mapping-hash" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Out() / Mapping hash</h4>

<p class="mt-6">Renaming variables from the inner to the outer ctx works by providing a mapping hash, where the “old” inner name points to the outer name that you want to use in the operation hosting that step.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; {:message =&gt; :message_from_policy}
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">Here, steps following <code class="text-purple">Policy::Create</code> will see a variable <code class="text-purple">:message_from_policy</code> merged into the ctx - which is the original <code class="text-purple">:message</code>, renamed.</p>

<h4 id="activity-variable-mapping-out-callable" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Out() / Callable</h4>

<p class="mt-6">An <code class="text-purple">Out()</code> filter can be any callable object following the <a href="#activity-internals-step-interface">step interface</a>.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; -&gt;(ctx, **) do
        return {} unless ctx[:message]

        { # you always have to return a hash from a callable!
          :message_from_policy =&gt; ctx[:message]
        }
      end
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">The callable receives the inner ctx that just left the actual step, here <code class="text-purple">Policy::Create</code>. You may run any Ruby code in the callable, even <code class="text-purple">if</code>s.</p>

<p class="mt-6">Note that a callable always must return a hash, which is then merged with the original outer ctx.</p>

<p class="mt-6">Be adviced that it is usually a better idea to maintain multiple smaller <code class="text-purple">Out()</code> callables for different variables. You might later decide to override them, debugging will be easier and the code is more maintainable. This was different when <code class="text-purple">:output</code> was the only way to filter outgoing variables and you had to create one big hash in a one single filter.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
You may also use an `:instance_method` to filter outgoing variables, similar to [how it's done with In()](#activity-variable-mapping-in-filter-method).

</p>
</div>

<h4 id="activity-variable-mapping-out-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Out() / Keyword arguments</h4>

<p class="mt-6">Just as with <code class="text-purple">In()</code> callables can receive keyword arguments.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; -&gt;(ctx, message: nil, **) do
        return {} if message.nil?

        { # you always have to return a hash from a callable!
          :message_from_policy =&gt; message
        }
      end
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">Any variable readable on the inner <code class="text-purple">ctx</code> that just left <code class="text-purple">Policy::Create</code> is available as a keyword argument for a callable. Note that you need to default it if its presence is not guaranteed.</p>

<h4 id="activity-variable-mapping-out-outer-context" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Out() / Outer context</h4>

<p class="mt-6">You can access the outer, original ctx by passing the <code class="text-purple">:with_outer_ctx</code> option to <code class="text-purple">Out()</code>.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message],

      Out(with_outer_ctx: true) =&gt; -&gt;(inner_ctx, outer_ctx:, **) do
        {
          errors: outer_ctx[:errors].merge(policy_message: inner_ctx[:message])
        }
      end
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">While the callable still needs to return a hash that is then merged with the original ctx, it’s possible to access variables from the outer ctx through the <code class="text-purple">:outer_ctx</code> keyword argument. This allows for merging deeper data structures, such as error objects.</p>

<h3 id="activity-variable-mapping-inject-" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Inject()</h3>

<p class="mt-6">An <code class="text-purple">Inject()</code> filter, as opposed to <code class="text-purple">In()</code>, does an existance check on the ctx using <code class="text-purple">ctx.key?(:variable)</code> before performing its logic. It is helpful in combination with <code class="text-purple">In()</code> filters, when using defaulted keyword arguments in a step or in nested operations.</p>

<ul>
  <li>It allows defaulting a variable when it’s absent in the ctx.</li>
  <li>It can pass-through a variable when it is present in the ctx, and only then.</li>
  <li>You can also statically set a variable, whether or not it is present using the <code class="text-purple">:override</code> option.</li>
</ul>

<p class="mt-6">Note that <code class="text-purple">Inject()</code> can be used without <code class="text-purple">In()</code>.</p>

<p class="mt-6">Check the following exemplary policy code.</p>

<pre class="mt-4"><code class="rounded">module Policy
  class Check
                                    # vvvvvvvvvvvvvvv-- defaulted keyword arguments
    def self.call(ctx, model:, user:, action: :create, **)
      decision = ApplicationPolicy.can?(model, user, action) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p class="mt-6">This policy implementation uses keyword arguments to automatically extract <code class="text-purple">:model</code>, <code class="text-purple">:user</code> and <code class="text-purple">:action</code> from the ctx. Note that the latter is defaulted to <code class="text-purple">:create</code>. Defaulting kwargs only works when the keyword variable is <strong>not passed</strong> into the step - if it’s <code class="text-purple">nil</code>, the defaulting will not get triggered.</p>

<p class="mt-6">You could now use <code class="text-purple">In()</code> filters to embed this policy step into your operation.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model, :action]
    # ...
  end
end
</code></pre>

<p class="mt-6">However, this will break because the <code class="text-purple">action</code> variable will never be defaulted to <code class="text-purple">:create</code>. The <code class="text-purple">In()</code> filter will <em>always</em> pass <code class="text-purple">:action</code> through when calling the policy, even when it’s absent.</p>

<p class="mt-6">The <code class="text-purple">Inject()</code> helper is designed to handle this case.</p>

<h4 id="activity-variable-mapping-inject-array-style" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Inject() / Array style</h4>

<p class="mt-6">Use <code class="text-purple">Inject()</code> in combination with <code class="text-purple">In()</code> to add variables to the filtered ctx, but only when they’re present in the outer ctx.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Inject() =&gt; [:action]
    # ...
  end
end
</code></pre>

<p class="mt-6">We call this <em>qualified pass-through</em>, it means the <code class="text-purple">:action</code> variable will only be passed into the filtered ctx if it exists on <code class="text-purple">ctx</code> when the filter is invoked.</p>

<h4 id="activity-variable-mapping-inject-defaulting" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Inject() / Defaulting</h4>

<p class="mt-6">Instead of hard-wiring defaulted keyword arguments into your step implementations, you can configure <code class="text-purple">Inject()</code> to set a default value to variables, if they’re absent in the ctx.</p>

<p class="mt-6">Here’s an example policy without any defaulting in the signature.</p>

<pre class="mt-4"><code class="rounded">module Policy
  class Check
                                    # vvvvvvv-- no defaulting!
    def self.call(ctx, model:, user:, action:, **)
      decision = ApplicationPolicy.can?(model, user, action) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p class="mt-6">Defaulting the <code class="text-purple">:action</code> variable via <code class="text-purple">Inject()</code> will improve the policy component’s reusability.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Inject(:action) =&gt; -&gt;(ctx, **) { :create }
    # ...
  end
end
</code></pre>

<p class="mt-6">The lambda is executed at runtime, just before the actual step is invoked. It provides access to the ctx object and allows extracting keyword arguments.</p>

<h4 id="activity-variable-mapping-inject-override" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Inject() / Override</h4>

<p class="mt-6">Use the <code class="text-purple">:override</code> option to always set a variable, even if it is already present in the incoming <code class="text-purple">ctx</code>.</p>

<pre class="mt-4"><code class="rounded">Inject(:action, override: true) =&gt; -&gt;(*) { :create } # always used.
</code></pre>

<p class="mt-6">This is helpful to set configuration variables for an activity while still using the well-established keyword argument mechanics. The <code class="text-purple">Policy::Create</code> class defines <code class="text-purple">:action</code> as a kwarg. This doesn’t necessarily mean the user can always inject and dictate the very value. Instead, we can override any injected value with the “hard-coded” <code class="text-purple">:create</code> value.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Inject(:action, override: true) =&gt; -&gt;(*) { :create } # always used.
    include ComposableVariableMappingDocTest::Steps
  end
end
</code></pre>

<p class="mt-6">The call as below will always use <code class="text-purple">action: :create</code>, even if something else is injected.</p>

<pre class="mt-4"><code class="rounded">signal, (ctx, _) = Trailblazer::Activity.(Song::Activity::Create,
  current_user: current_user,
  action: :update # this is always overridden.
)
puts ctx[:model] #=&gt; #&lt;Song id: 1, ...&gt;
</code></pre>

<h3 id="activity-variable-mapping-macro" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Macro</h3>

<p class="mt-6">As all DSL options the <code class="text-purple">In()</code>, <code class="text-purple">Out()</code> and <code class="text-purple">Inject()</code> helpers can be used from macros, providing the macro author a convenient way to define default filters.</p>

<pre class="mt-4"><code class="rounded">module Policy
  def self.Create()
    {
      task: Policy::Create,
      wrap_task: true,
      Trailblazer::Activity::Railway.In()  =&gt; {:current_user =&gt; :user},
      Trailblazer::Activity::Railway.In()  =&gt; [:model],
      Trailblazer::Activity::Railway.Out() =&gt; {:message =&gt; :message_from_policy},
    }
  end
end
</code></pre>

<p class="mt-6">In the options hash that a macro must return, you can use the helpers by referencing <code class="text-purple">Trailblazer::Activity::Railway</code>. Except for the prefixed constant, there is no difference or limitation to their usage.</p>

<p class="mt-6">They can be extended with options the macro user provides.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step Policy::Create(),
      Out() =&gt; {:message =&gt; :copied_message} # user options!
    # ...
  end
end
</code></pre>

<p class="mt-6">The user options will be merged into the macro options, resulting in <code class="text-purple">:message</code> being renamed to <code class="text-purple">:message_from_policy</code> and copied to <code class="text-purple">:copied_message</code>.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Before `trailblazer-activity-dsl-linear-1.0.0` and the `In()` and `Out()` helper shipped with it, any `:input` from the user would always override the macro's `:input` option.

</p>
</div>

<h3 id="activity-variable-mapping-inheritance" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Inheritance</h3>

<p class="mt-6">Subclasses can add and remove input and output filters - hence the term <em>composable</em>. This is a great tool when inherited operations replace particular steps and need to fine-tune ingoing or returned variables.</p>

<p class="mt-6">Consider the following base operation.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway

    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message],
      id: :policy
    # ...
  end
end
</code></pre>

<p class="mt-6">It defines two input and one output filter.</p>

<p class="mt-6">A sub operation could now replace the policy step. However, instead of redefining the i/o filters, they can be inherited and extended.</p>

<p class="mt-6">Here’s a potential inheriting operation.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Admin &lt; Create
    step Policy::Create,
      Out() =&gt; {:message =&gt; :raw_message_for_admin},
      inherit: [:variable_mapping],
      id: :policy,      # you need to reference the :id when your step
      replace: :policy
  end
end
</code></pre>

<p class="mt-6">This configuration is adding another <code class="text-purple">Out()</code> filter, resulting in a total filter setup as follows in the introspection.</p>

<pre class="mt-4"><code class="rounded">puts Trailblazer::Developer::Render::TaskWrap.(Song::Activity::Admin, id: :policy)

Song::Activity::Admin
# `-- policy
#     |-- task_wrap.input..................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
#     |   |-- input.init_hash.............................. ............................................. VariableMapping.initial_aggregate
#     |   |-- input.add_variables.0.994[...]............... {:current_user=&gt;:user}....................... VariableMapping::AddVariables
#     |   |-- input.add_variables.0.592[...]............... [:model]..................................... VariableMapping::AddVariables
#     |   `-- input.scope.................................. ............................................. VariableMapping.scope
#     |-- task_wrap.call_task..............Method
#     `-- task_wrap.output.................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Output
#         |-- output.init_hash............................. ............................................. VariableMapping.initial_aggregate
#         |-- output.add_variables.0.599[...].............. [:message]................................... VariableMapping::AddVariables::Output
#         |-- output.add_variables.0.710[...].............. {:message=&gt;:raw_message_for_admin}........... VariableMapping::AddVariables::Output
#        `-- output.merge_with_original................... ............................................. VariableMapping.merge_with_original
</code></pre>

<p class="mt-6">The new <code class="text-purple">Out()</code> filter setting <code class="text-purple">:raw_message_for_admin</code> is placed behind the inherited filter.</p>

<p class="mt-6">Note that <code class="text-purple">inherit: true</code> will, besides other options, also invoke the variable mapping inheritance.</p>

<!--


TODO: decompose trick (input )
-->

<h3 id="activity-variable-mapping-introspect" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Introspect</h3>

<p class="mt-6">You can visualize the pipelines around each step by using the <code class="text-purple">trailblazer-developer</code> gem.</p>

<pre class="mt-4"><code class="rounded">puts Trailblazer::Developer::Render::TaskWrap.(Song::Activity::Create, id: :policy)
</code></pre>

<p class="mt-6">This handy invocation will render the task wrap around <code class="text-purple">Song::Operation::Create</code>’s step <code class="text-purple">:policy</code>.</p>

<pre class="mt-4"><code class="rounded">Song::Activity::Create
`-- policy
    |-- task_wrap.input..................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Input
    |   |-- input.init_hash.............................. ............................................. VariableMapping.initial_aggregate
    |   |-- input.add_variables.0.994[...]............... {:current_user=&gt;:user}....................... VariableMapping::AddVariables
    |   |-- input.add_variables.0.592[...]............... [:model]..................................... VariableMapping::AddVariables
    |   `-- input.scope.................................. ............................................. VariableMapping.scope
    |-- task_wrap.call_task..............Method
    `-- task_wrap.output.................Trailblazer::Activity::DSL::Linear::VariableMapping::Pipe::Output
        |-- output.init_hash............................. ............................................. VariableMapping.initial_aggregate
        |-- output.add_variables.0.599[...].............. [:message]................................... VariableMapping::AddVariables::Output
        `-- output.merge_with_original................... ............................................. VariableMapping.merge_with_original
</code></pre>

<p class="mt-6">In i/o context, the interesting branches here are <code class="text-purple">task_wrap.input</code> and <code class="text-purple">task_wrap.output</code>. Sandwiched between generic library steps are your filter steps. The visualizer even renders filter configuration where possible.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
We're planning improvements on this part of `trailblazer-developer`. If you want to help out with better rendering, please [come chat to us](https://trailblazer.zulipchat.com).

</p>
</div>

<h3 id="activity-variable-mapping-input-output" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Input / Output</h3>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
With `trailblazer-2.1.1` and the bundled `trailblazer-activity-dsl-linear-1.0.0` gems, the recommended way of I/O is using [composable variable mapping]() via `In()` and `Out()`.

</p>
</div>

<p class="mt-6">Before the introduction of the composable <code class="text-purple">In()</code>, <code class="text-purple">Out()</code> and <code class="text-purple">Inject()</code> filters, variable mapping was done with the <code class="text-purple">:input</code> and <code class="text-purple">:output</code> option. This is still supported and not planned to be dropped. However, there are a bunch of drawbacks with using the monolithic, non-composable options.</p>

<ul>
  <li>Once used, the <code class="text-purple">:input</code>, <code class="text-purple">:output</code> and <code class="text-purple">:inject</code> option will overwrite any options set earlier (or later) via <code class="text-purple">In()</code>, <code class="text-purple">Out()</code> and <code class="text-purple">Inject()</code>. This will often lead to problems when using macros.</li>
  <li>The superseded options are basically impossible to debug, whereas the composable <code class="text-purple">In()</code> approach can <a href="#activity-variable-mapping-introspect">nicely display the computed set</a> of variables going in or out of a step.</li>
  <li>In future versions of Trailblazer we’re planning automatic “contracts” for steps along with type checking. This is not possible with the monolithic <code class="text-purple">:input</code> option.</li>
</ul>

<h4 id="activity-variable-mapping-input-output-input" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Input / Output / :input</h4>

<p class="mt-6">The <code class="text-purple">:input</code> option accepts any callable following the option interface.</p>

<pre class="mt-4"><code class="rounded">
step :create_model,
  input: :input_for_create_model
  # becomes
  In() =&gt; :input_for_create_model</code></pre>

<p class="mt-6"><code class="text-purple">:input</code> works identically to a single <code class="text-purple">In()</code> call.</p>

<h4 id="activity-variable-mapping-input-output-output" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Input / Output / :output</h4>

<p class="mt-6">The <code class="text-purple">:output</code> option, just like <code class="text-purple">:input</code>, accepts any callable following the option interface.</p>

<pre class="mt-4"><code class="rounded">
step :create_model,
  output: :output_for_create_model
  # becomes
  Out() =&gt; :output_for_create_model</code></pre>

<p class="mt-6"><code class="text-purple">:output</code> works identically to a single <code class="text-purple">Out()</code> call.</p>

<p class="mt-6">The <code class="text-purple">:output_with_outer_ctx</code> option is <a href="#activity-variable-mapping-out-outer-context">documented here</a>.</p>

<pre class="mt-4"><code class="rounded">
step :create_model,
  output: :output_for_create_model,
  output_with_outer_ctx: true
  # becomes
  Out(with_outer_ctx: true) =&gt; :output_for_create_model</code></pre>

<h4 id="activity-variable-mapping-input-output-inject" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Input / Output / :inject</h4>

<p class="mt-6"><code class="text-purple">:inject</code> works identically to a single <code class="text-purple">Inject()</code> call.</p>

<pre class="mt-4"><code class="rounded">
step :create_model,
  inject: :inject_for_create_model
  # becomes
  Inject() =&gt; :inject_for_create_model</code></pre>

<h2 id="activity-dependency-injection" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Dependency Injection</h2>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
WIP: This section is not final, yet.

</p>
</div>

<h3 id="activity-dependency-injection-overview" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Overview</h3>

<p class="mt-6">Very often your activity or one of the steps contained require particular objects and values to get their job done. Instead of hard-wiring those <em>“dependencies”</em> in the code it is good style to allow providing those objects by passing them into the activity at run-time. This is called dependency injection and is a <a href="https://en.wikipedia.org/wiki/Dependency_injection">common technique</a> in software engineering.</p>

<p class="mt-6">One way for using dependency injection is using keyword arguments for variables you need, and defaulting those in the step signature.</p>

<h3 id="activity-dependency-injection-mapping" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Mapping</h3>
<p class="mt-6">TODO</p>

<h3 id="activity-dependency-injection-dry-container" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Dry container</h3>
<p class="mt-6">TODO</p>

<p class="mt-6">defaulting in macros</p>

<h2 id="activity-macro-api" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Macro API</h2>

<p class="mt-6">Macros are short-cuts for inserting a task along with options into your activity.</p>

<h3 id="activity-macro-api-definition" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Definition</h3>

<p class="mt-6">They’re simple functions that return a hash with options described here.</p>

<pre class="mt-4"><code class="rounded">module MyMacro
  def self.NormalizeParams(name: :myparams, merge_hash: {})
    task = -&gt;((ctx, flow_options), _) do
      ctx[name] = ctx[:params].merge(merge_hash)

      return Trailblazer::Activity::Right, [ctx, flow_options]
    end

    # new API
    {
      task: task,
      id:   name
    }
  end
end
</code></pre>

<p class="mt-6">Two required options are <code class="text-purple">:id</code> and <code class="text-purple">:task</code>, the latter being the actual task you want to insert. The callable task needs to implement the [circuit interface].</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Please note that the actual task doesn't have to be a proc! Use a class, constant, object, as long as it exposes a `#call` method it will flow.

</p>
</div>

<h3 id="activity-macro-api-usage" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Usage</h3>

<p class="mt-6">To actually apply the macro you call the function in combination with <code class="text-purple">step</code>, <code class="text-purple">pass</code>, <code class="text-purple">fail</code>, etc.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step MyMacro::NormalizeParams(merge_hash: {role: "sailor"})
end
</code></pre>

<p class="mt-6">There’s no additional logic from Trailblazer happening here. The function returns a well-defined hash which is passed as an argument to <code class="text-purple">step</code>.</p>

<h3 id="activity-macro-api-options" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Options</h3>

<p class="mt-6">In the returned hash you may insert any valid DSL [step option], such as sequence options like <code class="text-purple">:before</code>, <code class="text-purple">Output()</code> and friends from the wiring API or even <code class="text-purple">:extensions</code>.</p>

<p class="mt-6">The following <code class="text-purple">FindModel</code> macro retrieves a configured model just like <code class="text-purple">trailblazer-macro</code>’s <code class="text-purple">Model()</code> and automatically wires the step’s <code class="text-purple">failure</code> output to a new terminus <code class="text-purple">not_found</code>.</p>

<pre class="mt-4"><code class="rounded">module MyMacro
  def self.FindModel(model_class)
    # the inserted task.
    task = -&gt;((ctx, flow_options), _) do
      model         = model_class.find_by(id: ctx[:params][:id])

      return_signal = model ? Trailblazer::Activity::Right : Trailblazer::Activity::Left
      ctx[:model]   = model

      return return_signal, [ctx, flow_options]
    end

    # the configuration needed by Trailblazer's DSL.
    {
      task: task,
      id:   :"find_model_#{model_class}",
      Trailblazer::Activity::Railway.Output(:failure) =&gt; Trailblazer::Activity::Railway.End(:not_found)
    }
  end
end
</code></pre>

<p class="mt-6">See how you can simply add <code class="text-purple">Output</code> wirings by using the well-established mechanics from the wiring API? Remember you’re not in an <code class="text-purple">Activity</code> or <code class="text-purple">Operation</code> namespace and hence need to use the fully-qualified constant reference <code class="text-purple">Trailblazer::Activity::Railway.Output()</code>.</p>

<p class="mt-6">To insert that step and its extended wiring, simply call the macro.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step MyMacro::FindModel(User)
end
</code></pre>

<p class="mt-6">When running the activity without a valid model ID, it will now terminate on <code class="text-purple">End.not_found</code>.</p>

<pre class="mt-4"><code class="rounded">signal, (ctx, _) = Trailblazer::Developer.wtf?(User::Create, [{params: {id: nil}}])
signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:not_found&gt;

`-- User::Create
    |-- Start.default
    |-- find_model_User
    `-- End.not_found
</code></pre>

<p class="mt-6">Using the wiring API in your own macros gives you a powerful tool for harnessing extended wiring without requiring the user to know about the details - the crucial point for a good API.</p>

<h4 id="activity-macro-api-options-subprocess" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Options / Subprocess</h4>

<p class="mt-6">You can even use other macros in custom macros, such as the <a href="#activity-wiring-api-subprocess"><code class="text-purple">Subprocess()</code> helper</a> for nesting activities.</p>

<p class="mt-6">Consider the following <code class="text-purple">Logger</code> activity.</p>

<pre class="mt-4"><code class="rounded">class Logger &lt; Trailblazer::Activity::Railway
  step :log

  def log(ctx, logged:, **)
    ctx[:log] = logged.inspect
  end
end
</code></pre>

<p class="mt-6">Along with the nested <code class="text-purple">Logger</code> step should also go <code class="text-purple">:input</code> and <code class="text-purple">:output</code> configuration. When using the <code class="text-purple">Logger</code> in multiple operation, you would need to repeat the options, so why not pack the entire configuration in a macro?</p>

<pre class="mt-4"><code class="rounded">module Macro
  def self.Logger(logged_name: )
    {
      id: "logger",
      input:  {logged_name =&gt; :logged},
      output: [:log],
      **Trailblazer::Activity::Railway.Subprocess(Logger), # nest
    }
  end
end
</code></pre>

<p class="mt-6">The nesting activity can now elegantly use the macro without inconvenient options.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step Macro::Logger(logged_name: :model) # we want to log {ctx[:model]}
end
</code></pre>

<h2 id="activity-internals" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Internals</h2>

<p class="mt-6">This section discusses low-level structures and is intended for engineers interested in changing or adding their own DSLs, the activity build process, or who want to optimize the Trailblazer internals (which is always appreciated!).</p>

<h3 id="activity-internals-introspection-api" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Introspection API</h3>

<p class="mt-6"><a href="https://github.com/trailblazer/trailblazer-activity" class="pink"><i class="fa fa-gem" aria-hidden="true"></i> trailblazer-activity 0.16.0</a></p>

<p class="mt-6">To introspect an activity and find out about steps, IDs and configuration, use the <code class="text-purple">Introspect.Nodes()</code> function.</p>

<p class="mt-6">Consider the following activity.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :validate
    step Subprocess(Save),
      id: :save
  end
end
</code></pre>

<h4 id="activity-internals-introspection-api-id" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Introspection API / ID</h4>

<p class="mt-6">You can retrieve a datastructure describing a particular task by ID.</p>

<pre class="mt-4"><code class="rounded">attrs = Trailblazer::Activity::Introspect.Nodes(Song::Activity::Create, id: :validate)
</code></pre>

<p class="mt-6">The returned <code class="text-purple">Attributes</code> object exposes <code class="text-purple">#id</code>, <code class="text-purple">#data</code> and <code class="text-purple">#task</code>.</p>

<!-- # FIXME: we need a skip-convert flag for Activity -> Operation -->
<pre class="mt-4"><code class="rounded">puts attrs.id   #=&gt; :validate
puts attrs.task #=&gt; #&lt;Trailblazer::Activity::TaskBuilder::Task user_proc=validate&gt;
puts attrs.data[:extensions] =&gt; []
</code></pre>

<h4 id="activity-internals-introspection-api-task" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Introspection API / Task</h4>

<p class="mt-6">It also accepts a <code class="text-purple">:task</code> option if you need to find attributes for a step where you only know the code component, not the ID. This is, for example, used in the tracing code.</p>

<pre class="mt-4"><code class="rounded">attrs = Trailblazer::Activity::Introspect.Nodes(Song::Activity::Create, task: Song::Activity::Save)
attrs.id #=&gt; :save
</code></pre>

<p class="mt-6">The returned <code class="text-purple">Attributes</code> instance behaves identically to the above.</p>

<h4 id="activity-internals-introspection-api-data" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Introspection API / Data</h4>

<p class="mt-6">Note that you can use <code class="text-purple">Attributes</code> to query <a href="/2.1/docs/internals.html#internals-dsl-introspect-data">custom data from the DSL</a>.</p>


<!-- @activity-circuit-interface <trailblazer-activity[1.0] activity, circuit interface, low level -->

<h3 id="activity-internals-circuit-interface" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Circuit Interface</h3>

<p class="mt-6">Activities and all tasks (or “steps”) are required to expose a <em>circuit interface</em>. This is the low-level interface. When an activity is executed, all involved tasks are called with that very signature.</p>

<p class="mt-6">Most of the times it is hidden behind the <a href="#FIXME">task interface</a> that you’re probably used to from your operations when using <code class="text-purple">step</code>. Under the hood, however, all callable circuit elements operate through that very interface.</p>

<p class="mt-6">The circuit interface consists of three things.</p>

<ul>
  <li>A circuit element has to expose a <code class="text-purple">call</code> method.</li>
  <li>The signature of the <code class="text-purple">call</code> method is <code class="text-purple">call((ctx, flow_options), **circuit_options)</code>.</li>
  <li>Return value of the <code class="text-purple">call</code> method is an array of format <code class="text-purple">[signal, [new_ctx, new_flow_options]]</code>.</li>
</ul>

<p class="mt-6">Do not fear those syntactical finesses unfamiliar to you, young padawan.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  def self.validate((ctx, flow_options), **_circuit_options)
    # ...
    return signal, [ctx, flow_options]
  end

  step task: method(:validate)
end
</code></pre>

<p class="mt-6">Both the <code class="text-purple">Create</code> activity itself and the <code class="text-purple">validate</code> step expose the circuit interface. Note that the <code class="text-purple">:task</code> option for <code class="text-purple">step</code> configures this element as a low-level circuit interface, or in other words, it will skip the wrapping with the task interface.</p>

<h4 id="activity-internals-circuit-interface-invocation" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Circuit Interface / Invocation</h4>

<p class="mt-6">Maybe it makes more sense now when you see how an activity is called manually? Here’s how to invoke <code class="text-purple">Create</code>.</p>

<pre class="mt-4"><code class="rounded">ctx          = {name: "Face to Face"}
flow_options = {}

signal, (ctx, _flow_options) = Create.([ctx, flow_options])

signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:success&gt;
ctx    #=&gt; {:name=&gt;\"Face to Face\", :validate_outcome=&gt;true}
</code></pre>

<p class="mt-6">Note that both <code class="text-purple">ctx</code> and <code class="text-purple">flow_options</code> can be just anything. Per convention, they respond to a hash interface, but theoretically it’s up to you how your network of activities and tasks communicates.</p>

<p class="mt-6">Check the implementation of <code class="text-purple">validate</code> to understand how you return a different signal or a changed <code class="text-purple">ctx</code>.</p>

<pre class="mt-4"><code class="rounded">def self.validate((ctx, flow_options), **_circuit_options)
  is_valid = ctx[:name].nil? ? false : true

  ctx    = ctx.merge(validate_outcome: is_valid) # you can change ctx
  signal = is_valid ? Trailblazer::Activity::Right : Trailblazer::Activity::Left

  return signal, [ctx, flow_options]
end
</code></pre>

<p class="mt-6">Make sure to always stick to the <code class="text-purple">return</code> signature on the circuit interface level.</p>

<h4 id="activity-internals-circuit-interface-signature" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Circuit Interface / Signature</h4>

<p class="mt-6">The circuit interface is a bit more clumsy but it gives you unlimited power over the way the activity will be run. And trust us, we’ve been playing with different APIs for two years and this was the easiest and fastest outcome.</p>

<pre class="mt-4"><code class="rounded">def self.validate((ctx, flow_options), **_circuit_options)
  # ...
  return signal, [ctx, flow_options]
end
</code></pre>

<p class="mt-6">The alienating signature uses <a href="https://docs.ruby-lang.org/en/2.1.0/syntax/methods_rdoc.html#label-Array+Decomposition">Ruby’s decomposition</a> feature. This only works because the first argument for <code class="text-purple">call</code> is actually an array.</p>

<p class="mt-6">Using this interface empowers you to fully take <em>control of the flow™</em>.</p>

<ul>
  <li>You can return any <code class="text-purple">signal</code> you want, not only the binary style in <em>steps</em>. Do not forget to wire that signal appropriately to the next task, though.</li>
  <li>If needed, the <code class="text-purple">ctx</code> object might be mutated or, better, replaced and a new version returned. This is the place where you’d start implementing an immutable version of Trailblazer’s <code class="text-purple">ctx</code>, for instance.</li>
  <li>Advanced features like tracing, input/output filters or type checking leverage the framework argument <code class="text-purple">flow_options</code>, which will be passed onwards through the entire activities flow. Know what you’re doing when using <code class="text-purple">flow_options</code> and <strong>always return it</strong> even if you’re not changing it.</li>
  <li>The <code class="text-purple">circuit_options</code> is another framework argument needed to control the start task and more. It is immutable and you don’t have to return it. The same <code class="text-purple">circuit_options</code> are guaranteed to be passed to all invoked tasks within one activity.</li>
</ul>

<p class="mt-6">Since in 99% the <code class="text-purple">circuit_options</code> are irrelevant for you, it’s nicer and faster to discard them instantly.</p>

<pre><code class="ruby light code-snippet wow fadeIn">
def validate((ctx, flow_options), *)
  # ...
end
</code></pre>

<p class="mt-6">Use the lonely <code class="text-purple">*</code> squat asterisk to do so.</p>

<h4 id="activity-internals-circuit-interface-circuit-options" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Circuit Interface / Circuit options</h4>

<p class="mt-6">The last positional argument when <code class="text-purple">call</code>ing an activity or task is called <em>circuit options</em>. It’s a library-level hash that is guaranteed to be identical for all tasks of an activity. In other words, all tasks of one activity will be called with the same <code class="text-purple">circuit_options</code> hash.</p>

<p class="mt-6">The following options are available.</p>

<h4 id="activity-internals-circuit-interface-start_task" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Circuit Interface / Start_task</h4>

<p class="mt-6">You can instruct the activity where to start - it doesn’t have to be the default start event! Use the <code class="text-purple">:start_task</code> option.</p>

<p class="mt-6">Consider this activity.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  # ...
  step :create
  step :validate
  step :save
end
</code></pre>

<p class="mt-6">Inject the <code class="text-purple">:start_task</code> option via the circuit options. The value has to be the actual callable task object. You can use the [introspection API] to grab it.</p>

<pre class="mt-4"><code class="rounded">circuit_options = {
  start_task: Trailblazer::Activity::Introspect::Nodes(B::Create, id: :validate).task
}

signal, (ctx, flow_options) = B::Create.([ctx, flow_options], **circuit_options)
</code></pre>

<p class="mt-6">Starting with <code class="text-purple">:validate</code>, the <code class="text-purple">:create</code> task will be skipped and only <code class="text-purple">:validate</code> and then <code class="text-purple">:save</code> will be executed.</p>

<p class="mt-6">Note that this is a low-level option that should not be used to build “reuseable” activities. If you want different behavior for differing contexts, you should compose different activities.</p>

<h4 id="activity-internals-circuit-interface-exec_context" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Circuit Interface / Exec_context</h4>

<p class="mt-6">When using the <code class="text-purple">step :method_name</code> DSL style, the <code class="text-purple">:exec_context</code> option controls what object provides the method implementations at runtime.</p>

<p class="mt-6">Usually, <code class="text-purple">Activity#call</code> will automatically set this, but you can invoke the <code class="text-purple">circuit</code> instead, and inject your own <code class="text-purple">exec_context</code>. This allows you to have a separate structure and implementation.</p>

<p class="mt-6">The following activity is such an “empty” structure.</p>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :create
  step :save
end
</code></pre>

<p class="mt-6">You may then use a class, object or module to define the implementation of your steps.</p>

<pre class="mt-4"><code class="rounded">class Create::Implementation
  def create(ctx, params:, **)
    ctx[:model] = Memo.new(params)
  end

  def save(ctx, model:, **)
    ctx[:model].save
  end
end
    end
</code></pre>

<p class="mt-6">This is really just a container of the desired step logic, with the familiar interface.</p>

<p class="mt-6">When invoking the <code class="text-purple">Create</code> activity, you need to call the <code class="text-purple">circuit</code> directly and inject the <code class="text-purple">:exec_context</code> option.</p>

<pre class="mt-4"><code class="rounded">circuit_options = {
  exec_context: C::Create::Implementation.new
}

signal, (ctx, flow_options) = C::Create.to_h[:circuit].([ctx, flow_options], **circuit_options)
</code></pre>

<p class="mt-6">While this bypasses <code class="text-purple">Activity#call</code>, it gives you a powerful tool for advanced activity design.</p>

<h4 id="activity-internals-circuit-interface-dsl" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Circuit Interface / DSL</h4>

<p class="mt-6">When using the DSL, use the <code class="text-purple">:task</code> option if you want your added task to be called directly with the circuit interface.  This skips the <code class="text-purple">TaskBuilder::Binary</code> wrapping.</p>

<pre><code class="ruby light code-snippet wow fadeIn">
class Create &lt; Trailblazer::Activity::Railway
  # ...
  step task: method(:validate)
end
</code></pre>

<!-- @activity-circuit-interface <trailblazer-activity[1.0] activity, circuit interface, low level -->

<p class="mt-6"><a name="activity-internals-task-interface"><!-- old name/link --></a></p>
<h3 id="activity-internals-step-interface" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Step Interface</h3>

<p class="mt-6"><em>a.k.a. <strong>Task interface</strong></em></p>

<p class="mt-6">The convenient high-level interface for a task implementation is - surprisingly - called <em>task interface</em>. It’s the one you will be working with 95% of your time when writing task logic.</p>

<p class="mt-6">This interface comprises of two parts.</p>

<ul>
  <li>The <strong>signature</strong> receives a mutable <code class="text-purple">ctx</code> object, and an optional list of keywords, often seen as <code class="text-purple">(ctx, **)</code>.</li>
  <li>The <strong>return value</strong> can be <code class="text-purple">true</code>, <code class="text-purple">false</code>, or a subclass of <code class="text-purple">Activity::Signal</code> to dictate the control flow.</li>
</ul>

<p class="mt-6">The return value does not control what is the next task. Instead, it informs the circuit runner about its outcome, and the circuit runner will find the task executed next.</p>

<pre class="mt-4"><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Activity::Railway
    def self.create_model(ctx, **)
      attributes = ctx[:attrs]           # read from ctx

      ctx[:model] = Memo.new(attributes) # write to ctx

      ctx[:model].save ? true : false    # return value matters
    end

    step method(:create_model)
    # ...
  end
end
</code></pre>

<p class="mt-6">Components (such as methods or callable objects) exposing the step interface always receive the <code class="text-purple">ctx</code> as the first (and only) positional argument. Keyword arguments may be used to extract variables from the <code class="text-purple">ctx</code>.</p>

<p class="mt-6">Depending on the step’s logic, you can write variables to the <code class="text-purple">ctx</code> object.</p>

<p class="mt-6">The return value can be either a subclass of <code class="text-purple">Trailblazer::Activity::Signal</code> or it will be evaluated to <code class="text-purple">true</code> or <code class="text-purple">false</code>.</p>

<h4 id="activity-internals-step-interface-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Keyword Arguments</h4>

<p class="mt-6">A cleaner way to access data from the <code class="text-purple">ctx</code> object is to use keyword arguments in the method signature. Trailblazer makes all <code class="text-purple">ctx</code> options available as kw args.</p>

<pre class="mt-4"><code class="rounded">def self.create_model(ctx, attrs:, **) # kw args!
  ctx[:model] = Memo.new(attrs)        # write to ctx

  ctx[:model].save ? true : false      # return value matters
end
</code></pre>

<p class="mt-6">You may use as many keyword arguments as you need - it will save you reading from <code class="text-purple">ctx</code> manually, gives you automatic presence checks, and allows defaulting, too.</p>

<!-- @activity-circuit-interface-class-method <trailblazer-activity[1.0] activity, circuit interface, low level, class method -->

<h4 id="activity-internals-step-interface-return-value" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Return Value</h4>

<p class="mt-6">Using the DSL, your task will usually be wrapped in a <code class="text-purple">TaskBuilder::Binary</code> object, which translates a <code class="text-purple">nil</code> and <code class="text-purple">false</code> return value to an <code class="text-purple">Activity::Left</code> signal, and all other return values to <code class="text-purple">Activity::Right</code>.</p>

<pre class="mt-4"><code class="rounded">def self.create_model(ctx, attrs:, **) # kw args!
  # ...
  ctx[:model].save ? true : false      # return value matters
end
</code></pre>

<p class="mt-6">In a Railway activity, a true value will usually result in the flow staying on the “success” path, where a falsey return value deviates to the “failure” track. However, eventually it’s the developer’s decision how to <a href="#activity-wiring-api">wire signals to connections</a>.</p>

<h4 id="activity-internals-step-interface-return-signal" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Return Signal</h4>

<p class="mt-6">You are not limited to true and falsey return values. Any subclass of <code class="text-purple">Activity::Signal</code> will simply be passed through without getting “translated” by the <code class="text-purple">Binary</code> wrapper. This allows to emit more than two possible states from a task.</p>

<pre class="mt-4"><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Activity::Railway
    DatabaseError = Class.new(Trailblazer::Activity::Signal) # subclass Signal

    def create_model(ctx, attrs:, **)
      ctx[:model] = Memo.new(attrs)

      begin
        return ctx[:model].save ? true : false  # binary return values
      rescue
        return DatabaseError                    # third return value
      end
    end
    # ...

    step :create_model,
      Output(DatabaseError, :handle_error) =&gt; Id(:handle_db_error)
    step :handle_db_error,
      magnetic_to: nil, Output(:success) =&gt; Track(:failure)
  end
end
</code></pre>

<p class="mt-6">The exemplary <code class="text-purple">DatabaseError</code> is being passed through to the routing and interpreted. It’s your job to make sure this signal is wired to a following task, track, or end (line 16).</p>

<p class="mt-6"><img src="/assets/activity-signal-58c2fae1f7128f84076750ef30429a5038f17feab42f76616a43e4c609177dda.png" /></p>

<p class="mt-6">Note that you don’t have to use the default binary signals at all (<code class="text-purple">Left</code> and <code class="text-purple">Right</code>).
<!-- <a href="#" class="pink">
   <i class="far fa-arrow-alt-circle-right"></i>
   <span class="medium">wiring</span>
</a>
 --></p>

<h4 id="activity-internals-step-interface-instance-method" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Instance Method</h4>

<p class="mt-6">The most convenient way is to use instance methods. Those may be declared after the <code class="text-purple">step</code> definitions, allowing you to first define the flow, then implement it.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  step :authorize
  # ...

  def authorize(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end
end
</code></pre>

<p class="mt-6">Use <code class="text-purple">:method_name</code> to refer to instance methods.</p>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Do *not use instance variables* (`@ivar`) ever as they're not guaranteed to work as expected. Always transport state via `ctx`.

</p>
</div>

<h4 id="activity-internals-step-interface-class-method" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Class Method</h4>

<p class="mt-6">A class method can implement a task of an activity. It needs to be declared as a class method using <code class="text-purple">self.method_name</code> and must precede the <code class="text-purple">step</code> declaration. Using Ruby’s <code class="text-purple">#method</code>, it can be passed to the <code class="text-purple">step</code> DSL.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  def self.authorize(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end

  step method(:authorize)
end
</code></pre>

<p class="mt-6">Instead of prefixing every method signature with <code class="text-purple">self.</code> you could use Ruby’s <code class="text-purple">class &lt;&lt; self</code> block to create class methods.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  class &lt;&lt; self
    def authorize(ctx, current_user:, **)
      current_user.can?(Memo, :create)
    end
    # more methods...
  end

  step method(:authorize)
end
</code></pre>

<p class="mt-6">In TRB 2.0, instance methods in operations were the preferred way for implementing tasks. This was a bit more convenient, but required the framework to create an object instance with every single activity invocation. It also encouraged users to transport state via the activity instance itself (instead of the <code class="text-purple">ctx</code> object), which led to bizarre issues.</p>

<p class="mt-6">Since 2.1, the approach is as stateless and functional as possible, as we now prefer class methods.</p>

<!-- @activity-circuit-interface-callable <trailblazer-activity[1.0] activity, circuit interface, low level, class method -->

<h4 id="activity-internals-step-interface-callable" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Callable</h4>

<p class="mt-6">As a matter of fact, you can use any callable object. That means, any object that responds to <code class="text-purple">#call</code> is suitable as a task implementation.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  # ...
  step AuthorizeForCreate
end
</code></pre>

<p class="mt-6">When using a class, it needs to expose a class method <code class="text-purple">#call</code>. This is ideal for more complex task code that needs to be decomposed into smaller private methods internally.</p>

<pre class="mt-4"><code class="rounded">class AuthorizeForCreate
  def self.call(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end
end
</code></pre>

<p class="mt-6">The signature of <code class="text-purple">#call</code> is identical to the other implementation styles.</p>

<h4 id="activity-internals-step-interface-module" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Step Interface / Module</h4>

<p class="mt-6">Keep in mind that you don’t have to implement every task in the activity itself - it can be outsourced to a module.</p>

<pre class="mt-4"><code class="rounded">module Authorizer
  module_function

  def memo_create(ctx, current_user:, **)
    current_user.can?(Memo, :create)
  end
end
</code></pre>

<p class="mt-6">When using <code class="text-purple">module_function</code>, every method will be a “class” method automatically.</p>

<p class="mt-6">In the activity, you can reference the module’s methods using our old friend <code class="text-purple">method</code>.</p>

<pre class="mt-4"><code class="rounded">class Memo::Create &lt; Trailblazer::Activity::Railway
  step Authorizer.method(:memo_create)
  # ...
end
</code></pre>

<h2 id="activity-taskwrap" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">TaskWrap</h2>

<p class="mt-6">The <em>taskWrap</em> is the “<code class="text-purple">around_filter</code>” of Trailblazer. It allows adding steps before and after actual tasks without having to change the activity, and without having to introduce <code class="text-purple">if</code>s.</p>

<p class="mt-6">Some prominent examples for taskWrap usage in the wild are <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear/blob/f54ce384f57dde063f77a769487fc38023217910/lib/trailblazer/activity/dsl/linear/variable_mapping.rb">variable mapping</a> and tracing happening in <a href="https://github.com/trailblazer/trailblazer-developer/blob/de84d67ac390fee5e98ffc0a172cf80141e06c81/lib/trailblazer/developer/trace.rb"><code class="text-purple">#wtf?</code></a>. Those are features completely separated from the core code. You can use the taskWrap mechanics to inject static wraps at compile time (as it’s done for, say, the <code class="text-purple">In()</code> feature), or at runtime, the way <code class="text-purple">#wtf?</code> is built.</p>

<p class="mt-6"><img src="/assets/task_wrap_validate-2ca816c5a0ea2dd16997f39ca8913009e6f22a0e5ec68134f260ba378a738210.png" /></p>

<p class="mt-6">It’s possible to configure a specific taskWrap for a particular step, or run the same one for all steps encountered while running an activity, even with nesting.</p>

<h3 id="activity-taskwrap-example" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Example</h3>

<p class="mt-6">Let’s discuss the taskWrap with the following simple <code class="text-purple">Create</code> activity that you’ve probably met before.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step :validate
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="mt-6">We’re using an imaginary <code class="text-purple">MyAPM</code> gem that provides a convenient interface for starting and stopping instrumentation.</p>

<pre class="mt-4"><code class="rounded">span = MyAPM.start_span("validate", payload: {time: Time.now})
# do whatever you have to...
span.finish(payload: {time: Time.now})
</code></pre>

<h3 id="activity-taskwrap-step" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Step</h3>

<p class="mt-6">In order to execute the instrumentation, we have to write two taskWrap steps, one to start, one for finishing the instrumentation. Those steps look similar to “ordinary” activity steps, but expose the taskWrap interface.</p>

<pre class="mt-4"><code class="rounded">module MyAPM # Advanced performance monitoring, done right!
  module Extension
    def self.start_instrumentation(wrap_ctx, original_args)
      (ctx, _flow_options), circuit_options = original_args

      activity  = circuit_options[:activity] # currently running Activity.
      task      = wrap_ctx[:task]            # the current "step".

      task_id   = Trailblazer::Activity::Introspect.Nodes(activity, task: task).id

      span      = MyAPM.start_span("operation.step", payload: {id: task_id})

      wrap_ctx[:span] = span

      return wrap_ctx, original_args
    end
  end
end
</code></pre>

<p class="mt-6">A taskWrap step receives two positional arguments, the <code class="text-purple">wrap_ctx</code> that is used to transport taskWrap-specific data across taskWrap steps, and the <code class="text-purple">original_args</code> that represent how the circuit called the currently invoked task.</p>

<p class="mt-6">Above, you can see how it’s possible to retrieve the currently invoked <code class="text-purple">task</code> and its <code class="text-purple">activity</code>.</p>

<p class="mt-6">We then store the <code class="text-purple">span</code> object in the <code class="text-purple">wrap_ctx</code> so the finishing code can close that span in the second taskWrap step <code class="text-purple">#finish_instrumentation</code>.</p>

<pre class="mt-4"><code class="rounded">module MyAPM # Advanced performance monitoring, done right!
  module Extension
    def self.finish_instrumentation(wrap_ctx, original_args)
      ctx   = original_args[0][0]
      span  = wrap_ctx[:span]

      span.finish(payload: ctx.inspect)

      return wrap_ctx, original_args
    end
  end
end
</code></pre>

<p class="mt-6">As you can see, the <code class="text-purple">span</code> object can be fetched from <code class="text-purple">wrap_ctx</code> as the second step is run somewhere after <code class="text-purple">start_instrumentation</code>.</p>

<h3 id="activity-taskwrap-call_task" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">call_task</h3>

<p class="mt-6">Each taskWrap has at least one element, the <code class="text-purple">call_task</code> step that calls the actual task. Sometimes this task is a method, such as <code class="text-purple">#validate</code>, sometimes a nested activity, and so on.</p>

<h3 id="activity-taskwrap-runtime" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Runtime</h3>

<p class="mt-6">The taskWrap can be extended at runtime, when <code class="text-purple">call</code>ing an activity. This allow for adding features to steps without having to change the actual business code.</p>

<h4 id="activity-taskwrap-runtime-extension" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Runtime / Extension</h4>

<p class="mt-6">To actually run the <code class="text-purple">Song::Activity::Create</code> activity with this new taskWrap, we need to build a runtime extension.</p>

<pre class="mt-4"><code class="rounded">apm_extension = Trailblazer::Activity::TaskWrap::Extension(
  [MyAPM::Extension.method(:start_instrumentation),  id: "my_apm.start_span",  prepend: "task_wrap.call_task"],
  [MyAPM::Extension.method(:finish_instrumentation), id: "my_apm.finish_span", append: "task_wrap.call_task"],
)
</code></pre>

<p class="mt-6">You can configure where to insert the taskWrap steps using <code class="text-purple">:append</code> or <code class="text-purple">:prepend</code>.</p>

<h4 id="activity-taskwrap-runtime-invoke" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Runtime / Invoke</h4>

<p class="mt-6">We’re now all set to inject that new taskWrap into the execution of our business activity. In the following example, the <code class="text-purple">my_wrap</code> hash is configured in a way that our extension is run around every task in <code class="text-purple">Create</code>, even for <code class="text-purple">Create</code> itself.</p>

<pre class="mt-4"><code class="rounded">my_wrap = Hash.new(apm_extension)

Song::Activity::Create.invoke(
  [
    # ctx:
    {
      song: {title: "Timebomb"},
      seq: []
    }
  ],
  wrap_runtime: my_wrap # runtime taskWrap extensions!
)
</code></pre>

<p class="mt-6">This will result in the same taskWrap being applied to every step of the activity execution path, and for <code class="text-purple">#validate</code>, looks like so.</p>

<p class="mt-6"><img src="/assets/task_wrap_validate-2ca816c5a0ea2dd16997f39ca8913009e6f22a0e5ec68134f260ba378a738210.png" /></p>

<h4 id="activity-taskwrap-runtime-step-filter" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Runtime / Step filter</h4>

<p class="mt-6">You don’t have to run a taskWrap extension around every step. It is possible to configure an extension only being applied to a particular step in your activity. Let’s invoke the new APM taskWrap only around <code class="text-purple">#validate</code>.</p>

<pre class="mt-4"><code class="rounded">validate_task = Trailblazer::Activity::Introspect
  .Nodes(Song::Activity::Create, id: :validate) # returns Node::Attributes
  .task                                         # and the actually executed task from the circuit.

my_wrap = {validate_task =&gt; apm_extension}
</code></pre>

<p class="mt-6">Note that <code class="text-purple">my_wrap</code> can map specific tasks to their taskWrap extension.</p>

<p class="mt-6">When running <code class="text-purple">Create</code> with the new configuration, the APM code is only called for <code class="text-purple">#validate</code>.</p>

<pre class="mt-4"><code class="rounded">Song::Activity::Create.invoke(
  [
    # ctx:
    {
      song: {title: "Timebomb"},
      seq: []
    }
  ],
  wrap_runtime: my_wrap # runtime taskWrap extensions!
)
</code></pre>

<h4 id="activity-taskwrap-runtime-top-activity" class="font-bold text-neutral-500 lg:text-1xl mt-4 text-xl">Runtime / Top activity</h4>

<p class="mt-6">It’s important to understand that even the top activity <code class="text-purple">Song::Activity::Create</code> is run using a taskWrap, so if you want to apply APM only to this particular “step”, you could do so as follows.</p>

<pre class="mt-4"><code class="rounded">my_wrap = {Song::Activity::Create =&gt; apm_extension}
</code></pre>

<h3 id="activity-taskwrap-static" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Static</h3>

<p class="mt-6">Instead of dynamically adding taskWrap extensions at runtime, in some cases you might want to do so when defining the activity class, at compile-time. For example, the <code class="text-purple">In()</code> and <code class="text-purple">Out()</code> filter DSL uses a static taskWrap extension to add steps around a specific task.</p>

<p class="mt-6">This can be achieved with the <code class="text-purple">WrapStatic()</code> helper.</p>

<pre class="mt-4"><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step :validate,
      Extension() =&gt; Trailblazer::Activity::TaskWrap::Extension::WrapStatic(
        [MyAPM::Extension.method(:start_instrumentation),  id: "my_apm.start_span",  prepend: "task_wrap.call_task"],
        [MyAPM::Extension.method(:finish_instrumentation), id: "my_apm.finish_span", append: "task_wrap.call_task"],
      )
    left :handle_errors
    step :notify
    include T.def_steps(:create_model, :validate, :notify)
  end
end
</code></pre>

<p class="mt-6">Obviously, you’d introduce a macro here to hide all those specific details to the user of your extension.</p>

<p class="mt-6">When running, the APM instrumentation is run only around <code class="text-purple">#validate</code>.</p>

<pre class="mt-4"><code class="rounded">signal, (ctx, _) = Song::Activity::Create.invoke([ctx, {}])
</code></pre>

<h3 id="activity-taskwrap-introspection" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Introspection</h3>

<p class="mt-6">You can use our web-based debugger to introspect the static taskWrap of any step.</p>

<!-- example :if -->

<!-- Example tracing
https://gist.github.com/matheusca/893dc965bd06c97625b2cb2adae418b4#file-test-rb-L22
 -->

<h2 id="activity-troubleshooting" class="text-2xl font-bold text-neutral-500 lg:text-3xl mt-6">Troubleshooting</h2>

<p class="mt-6">Even though tracing and <code class="text-purple">wtf?</code> attempt to make your developer experience as smooth as possible, sometimes there are annoying issues.</p>

<h3 id="activity-troubleshooting-type-error" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Type Error</h3>

<p class="mt-6">It’s a common error to use a bare <code class="text-purple">Hash</code> (with string keys!) instead of a <code class="text-purple">Trailblazer::Context</code> object when running an activity. While symbolized hashes are not a problem, string keys will fail.</p>

<pre class="mt-4"><code class="rounded">ctx = {"message" =&gt; "Not gonna work!"} # bare hash.
Bla.([ctx])
</code></pre>

<p class="mt-6">The infamous <code class="text-purple">TypeError</code> means your context object can’t convert strings into symbol keys. This is required when calling your steps with keyword arguments.</p>

<pre class="mt-4"><code class="rounded">TypeError: wrong argument type String (expected Symbol)
</code></pre>

<p class="mt-6">Use <code class="text-purple">Trailblazer::Context</code> as a wrapper.</p>

<pre class="mt-4"><code class="rounded">ctx = Trailblazer::Context({"message" =&gt; "Yes, works!"})

signal, (ctx, _) = Bla.([ctx])
</code></pre>

<p class="mt-6">The <code class="text-purple">Context</code> object automatically converts string keys to symbols.</p>

<h3 id="activity-troubleshooting-wrong-circuit" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Wrong circuit</h3>

<p class="mt-6">When using the same task multiple times in an activity, you might end up with a wiring you’re not expecting. This is due to Trailblazer internally keying tasks by their object identity.</p>

<pre class="mt-4"><code class="rounded">class Update &lt; Trailblazer::Activity::Railway
  class CheckAttribute &lt; Trailblazer::Activity::Railway
    step :valid?
  end

  step :find_model
  step Subprocess(CheckAttribute), id: :a
  step Subprocess(CheckAttribute), id: :b # same task!
  step :save
end
</code></pre>

<p class="mt-6">When introspecting this activity, you will see that the <code class="text-purple">CheckAttribute</code> task is present only once.</p>

<p class="mt-6">You need to create a copy of the method or the class of your callable task in order to fix this and have two identical steps.</p>

<pre class="mt-4"><code class="rounded">class Update &lt; Trailblazer::Activity::Railway
  class CheckAttribute &lt; Trailblazer::Activity::Railway
    step :valid?
  end

  step :find_model
  step Subprocess(CheckAttribute), id: :a
  step Subprocess(Class.new(CheckAttribute)), id: :b # different task!
  step :save
end
</code></pre>

<h3 id="activity-troubleshooting-illegal-signal-error" class="font-bold text-neutral-500 lg:text-2xl mt-6 text-xl">Illegal Signal Error</h3>

<p class="mt-6">As the name suggests, the <code class="text-purple">IllegalSignalError</code> exception is raised when a step returns a signal that is not registered at <a href="/2.1/docs/activity.html#activity-internals-build-structures-compilation">compile time</a>. The routing algorithm is not able to find a connection for the returned signal and raises an error at run-time.</p>

<p class="mt-6">Usually, you encounter this beautiful exception when using the <a href="#activity-internals-circuit-interface">circuit interface</a> signature for a step, and returning a “wrong” signal that is not wired to an on-going next task.</p>

<p class="mt-6">Other common cases may be</p>

<ul>
  <li>Steps which are not wrapped by [TaskBuilder], for example: <code class="text-purple">step task: method(:validate)</code></li>
  <li><a href="/2.1/docs/activity.html#activity-macro-api">User defined macros</a>.</li>
</ul>

<pre class="mt-4"><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  def self.validate((ctx, flow_options), **circuit_options)
    return :invalid_signal, [ctx, flow_options], circuit_options
  end

  step task: method(:validate)
end

ctx = {"message" =&gt; "Not gonna work!"} # bare hash.
Create.([ctx])

# IllegalSignalError: Create:
# Unrecognized Signal `:invalid_signal` returned from `Method: Create.validate`. Registered signals are,
# - Trailblazer::Activity::Left
# - Trailblazer::Activity::Right
</code></pre>

<p class="mt-6">The exception helps by displaying both the actually returned signal and the registered, wired signals for this step.</p>


<div class="rounded flex p-4 gap-4 mt-5 bg-bg-purple-1/50">
          <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
<p>
  
Important notes should be created via the `info` helper. We still need to allow Markdown in these boxes, as it improves usability by a million times.

</p>
</div>

<div class="rounded flex p-4 gap-4 mt-5 bg-bg-orange">
          <img src="/assets/light_bulb_icon-86b61187949258b0b8370420dd5f5f7578f8d662e8404d553fc41813b33a5484.svg" />
<p>
  
Important notes that are meant to warn the user should be created via the `warning` helper. We still need to allow Markdown in these boxes, as it improves usability by a million times.
Also, should the icon be centered or at the top, vertically?

</p>
</div>

        </div>
        <div class="relative" id="right-toc">
          <div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-overview">
  <h4 class="font-base font-bold leading-10 pl-2">
    Overview
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-overview-anatomy">Anatomy</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-overview-dsl">DSL</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-overview-invocation">Invocation</a>

    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-strategy">
  <h4 class="font-base font-bold leading-10 pl-2">
    Strategy
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-strategy-path">Path</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-path-output">Output</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-path-end">End</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-path-multiple-references">Multiple References</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-strategy-railway">Railway</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-railway-wiring">Wiring</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-railway-fail">Fail</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-railway-pass">Pass</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-railway-left">Left</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-railway-notes">Notes</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-strategy-fasttrack">FastTrack</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-fasttrack-passfast">PassFast</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-fasttrack-failfast">FailFast</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-fasttrack-fasttrack">FastTrack</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-strategy-fasttrack-notes">Notes</a>
    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-wiring-api">
  <h4 class="font-base font-bold leading-10 pl-2">
    Wiring API
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-output-">Output()</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-output-implicit-signal">Implicit signal</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-output-adding-outputs">Adding outputs</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-end-">End()</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-end-adding-ends">Adding ends</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-id-">Id()</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-track-">Track()</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-terminus">Terminus</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-path-">Path()</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-path-join">Join</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-path-railway">Railway</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-path-end_task-end_id-deprecation">End_task/End_id Deprecation</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-wiring-api-subprocess">Subprocess</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-subprocess-wiring">Wiring</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-wiring-api-subprocess-end">End</a>
    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-dsl-options">
  <h4 class="font-base font-bold leading-10 pl-2">
    DSL Options
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-dsl-options-magnetic_to">magnetic_to</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-dsl-options-extensions">extensions</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-dsl-options-inherit">Inherit</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-dsl-options-sequence-options">Sequence Options</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-sequence-options-id">id</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-sequence-options-delete">Delete</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-sequence-options-before">Before</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-sequence-options-after">After</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-sequence-options-replace">Replace</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-dsl-options-patching">Patching</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-patching-patch">Patch</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-dsl-options-patching-patch-option">Patch Option</a>
    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-variable-mapping">
  <h4 class="font-base font-bold leading-10 pl-2">
    Variable Mapping
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-overview">Overview</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-composable-i-o">Composable I/o</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-in-">In()</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-in-mapping-hash">Mapping hash</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-in-limiting-array">Limiting array</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-in-callable">Callable</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-in-filter-method">Filter method</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-in-keyword-arguments">Keyword arguments</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-out-">Out()</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-out-limiting-array">Limiting array</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-out-mapping-hash">Mapping hash</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-out-callable">Callable</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-out-keyword-arguments">Keyword arguments</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-out-outer-context">Outer context</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-inject-">Inject()</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-inject-array-style">Array style</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-inject-defaulting">Defaulting</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-inject-override">Override</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-macro">Macro</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-inheritance">Inheritance</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-introspect">Introspect</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-variable-mapping-input-output">Input / Output</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-input-output-input">:input</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-input-output-output">:output</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-variable-mapping-input-output-inject">:inject</a>
    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-dependency-injection">
  <h4 class="font-base font-bold leading-10 pl-2">
    Dependency Injection
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-dependency-injection-overview">Overview</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-dependency-injection-mapping">Mapping</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-dependency-injection-dry-container">Dry container</a>

    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-macro-api">
  <h4 class="font-base font-bold leading-10 pl-2">
    Macro API
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-macro-api-definition">Definition</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-macro-api-usage">Usage</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-macro-api-options">Options</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-macro-api-options-subprocess">Subprocess</a>
    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-internals">
  <h4 class="font-base font-bold leading-10 pl-2">
    Internals
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-internals-introspection-api">Introspection API</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-introspection-api-id">ID</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-introspection-api-task">Task</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-introspection-api-data">Data</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-internals-circuit-interface">Circuit Interface</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-circuit-interface-invocation">Invocation</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-circuit-interface-signature">Signature</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-circuit-interface-circuit-options">Circuit options</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-circuit-interface-start_task">Start_task</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-circuit-interface-exec_context">Exec_context</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-circuit-interface-dsl">DSL</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-internals-step-interface">Step Interface</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-keyword-arguments">Keyword Arguments</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-return-value">Return Value</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-return-signal">Return Signal</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-instance-method">Instance Method</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-class-method">Class Method</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-callable">Callable</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-internals-step-interface-module">Module</a>
    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-taskwrap">
  <h4 class="font-base font-bold leading-10 pl-2">
    TaskWrap
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-taskwrap-example">Example</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-taskwrap-step">Step</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-taskwrap-call_task">call_task</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-taskwrap-runtime">Runtime</a>

    
      <a class="documentation-right-nav-link text-grey" href="#activity-taskwrap-runtime-extension">Extension</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-taskwrap-runtime-invoke">Invoke</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-taskwrap-runtime-step-filter">Step filter</a>
    
      <a class="documentation-right-nav-link text-grey" href="#activity-taskwrap-runtime-top-activity">Top activity</a>
    
  
    <a class="documentation-right-nav-link" href="#activity-taskwrap-static">Static</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-taskwrap-introspection">Introspection</a>

    
  
</div>


<div class="hidden bg-white pt-5 px-5 w-56 shrink-0 text-bg-blue fixed overflow-y-scroll h-[40rem]" id="right-toc-activity-troubleshooting">
  <h4 class="font-base font-bold leading-10 pl-2">
    Troubleshooting
  </h4>
  <!-- bg-bg-orange to "highlight" the link -->
  
    <a class="documentation-right-nav-link" href="#activity-troubleshooting-type-error">Type Error</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-troubleshooting-wrong-circuit">Wrong circuit</a>

    
  
    <a class="documentation-right-nav-link" href="#activity-troubleshooting-illegal-signal-error">Illegal Signal Error</a>

    
  
</div>


        </div>
      </div>
    </div>
  </div>
</section>

<section class="px-10 py-22 bg-bg-purple-3">
  <h2 class="section-header font-bold">
    Is there anything unanswered?
    <br/>
    Get in touch with
    <span class="font-black">
      TRAILBLAZER
    </span>
    <a href="" class="base-button bg-purple text-white mt-15 mx-auto">Chat with us</a>
  </h2>
</section>

<footer class="lg:text-left bg-bg-blue py-16 text-white text-center text-base">
  <div class="lg:flex justify-between w-11/12 max-w-[80rem] mx-auto">
    <div class="lg:flex lg:flex-col lg:justify-between">
      <a href="/2.1/" class="block shrink-0 w-fit mx-auto lg:mx-0" >
        <img class="w-48" src="/assets/logo_white-77ad0d4ab1d29ebcc47fa603cb7437f4059138ab621c41cba097ed6d4f1c98e2.svg" />
      </a>
      <div class="lg:block hidden">
        © 2023 Trailblazer GmbH
      </div>
    </div>
    <div class="lg:flex lg:gap-20 xl:gap-40">
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl hover:scale-105" href="#">Documentation</a>
        <a class="hover:scale-105" href="#">About</a>
        <a class="hover:scale-105" href="#">Community</a>
        <a class="hover:scale-105" href="#">Blog</a>
        <a class="hover:scale-105" href="#">Legal</a>
      </div>
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl hover:scale-105" href="#">Products</a>
        <a class="hover:scale-105" href="#">Trailblazer</a>
        <a class="hover:scale-105" href="#">Trailblazer Pro</a>
        <a class="hover:scale-105" href="#">Support</a>
      </div>
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl hover:scale-105" href="#">Learn</a>
        <a class="hover:scale-105" href="#">What is Trailblazer?</a>
        <a class="hover:scale-105" href="#">Trailblazer PRO</a>
        <a class="hover:scale-105" href="#">Tips and Tutorials</a>
        <a class="hover:scale-105" href="#">Chat</a>
      </div>
    </div>
  </div>
  <div class="lg:hidden mt-15">
    © 2023 Trailblazer GmbH
  </div>
</footer>


  </body>
</html>
