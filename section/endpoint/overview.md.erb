Whenever you need an operation "around" your actual business operation, to add authentication, policy checks or more steps "around" your domain code, you want to start using endpoints.

Instead of you manually calling operations, endpoints are planned to become the canonical way of invoking operations in controllers, jobs and tests.

* Endpoints provide a simple way of defining possible outcomes of an operation
* They come with a simple runtime API that allows you to provide matchers for each outcome. For example, you can handle a "model not found" outcome generically, but override how a success outcome is handled.
* Endpoints are a much better abstraction to customize how your operations are run. In current projects, many users override `#call_with_public_method` to add aliases or tweak standard variables in the ctx. This now becomes nothing but another step in the endpoint, before the domain operation.





<%= h2 "Overview" %>

An endpoint is defined per *use case*, which usually corresponds to a particular controller action and operation. In this example, an `Update` operation is embraced by its endpoint. You may add arbitrary steps to the endpoint, such as authentication, authorization or data filtering that is unrelated to your business domain.

<%= image_tag "endpoint-update.png" %>

Endpoints define a set of possible outcomes: besides `success` and `failure` there might be additional, more fine-grained termini like `not_found` or even `credit_card_invalid`. It's the job of your team to decide which generic, reusable termini to introduce.

The key idea is to have specific handlers for all outcomes that you write once, while allowing to override specifc cases. In other words, `not_found` renders a 404 error automatically, but you deal with `success` manually.

<%= h3 "Example" %>

Endpoints and the matcher interface can be used anywhere, in controllers, tests, background jobs, or wherever you need to invoke an operation. This example focuses on controllers.

<%= code "endpoint-controller" %>

Endpoints (currently!) have to be defined on the controller class level using the `::endpoint` method. Calling the endpoint and your operation works via the `#invoke` instance method, which you typically place in a controller action.

The matcher interface in the block is where it gets interesting. It allows to provide code blocks to handle different outcomes. However, the beautiful part is that you can inherit generic matchers from the `ApplicationController` (or wherever you inherit from).

<%= code "application-controller", file: "../../app/controllers/application_controller.rb", collapse: "config" %>

Here, using `default_block`, generic matchers can be defined.

The `Controller` module from the `endpoint` gem ships with several configuration directives, like what to pass into the `ctx`, default matchers, or whether or not fast-track termini should be wired to the standard railway termini.

<<!--
As visible in this illustreous diagram, invoking an endpoint usually involves two steps.

1. Running authentication and authorization, allowing to move this logic from the controller's `before_filter`s to a traceable activity.
2. Running the actual domain code, your `Update` operation.

The key of the endpoint is to specify generic outcomes to be reused across the entire application: `not_found` or `not_authorized` are well-defined outcomes that can now be handled by generic code you write once.

<%= info do %>
Letting the endpoint handle the authentication, policy checks and more is completely up to you. If desired, or during a refactoring, leave this code in your `before_filter`s.
<% end %>






Endpoints will be the canonical, recommended way to running operations.

 -->
