<%= h2 "Mechanics" %>

This chapter discusses the fundamental building blocks and concepts of operations: steps, signals, the ctx object and how to run operations.

<%= h3 "Invocation" %>

Operations represent functions in your application, both in a domain-oriented way and from a programmatical point of view. That is why there's only one way to run an operation.

<%= h4 "Call" %>

The `#call` class method is how you run your operation along with its steps.

<%= code "instance-method-call" %>

And that's literally the only way to invoke your steps. It is not allowed to run a subset of steps, only. If you need that, you might have to introduce a new operation, or [change the wiring](#activity-wiring-api) to achieve the same effect.

<%= h4 "Implicit call" %>

In Ruby, it's possible to skip the word `call`. That's why you might often see invocations of operations that might look a bit cryptic in the beginning.

<%= code "instance-method-implicit-call" %>

Anyhow, the implicit call style underlines the functional aspect of an operation. Since, per convention, the operation name is a verb (e.g. `Create`) there's no need to think of another verb to actually _run_ that "verb". That's why we love the implicit call style!

<%= h4 "Input variables" %>

Any variables you pass into the invocation will be readable by all steps of the operation (unless configured otherwise).

<%= code "ctx-read-call" %>

Here, the `:params` variable can be accessed in each step via the `ctx` object, which is the first positional argument passed to each step.

<%= code "ctx-read", collapse: :meths %>

While this is a breathtaking feature of Trailblazer, it's a bit clumsy and we got a more convenient way to read from `ctx`.

<%= h4 "Keyword arguments" %>

Instead of manually checking `ctx` for the presence of a particular variable, you can add a keyword argument to your step's signature.

<%= code "ctx-read-kwargs" %>

The `:params` variable is now a local variable `params` in your step method.

Another benefit: if the caller of your operation fails to provide `:params`, Ruby will complain automatically of a missing keyword!

<%= code "kwargs-error" %>

Ruby's epic [keyword arguments](https://thoughtbot.com/blog/ruby-2-keyword-arguments) even allow defaulting of variables, should they be absent in `ctx`.

Note that you can use any number of keyword arguments in your signature.

<%= h4 "Writing state" %>

It is also possible to _write_ to `ctx`, should you fancy to publish information out of the step.

<%= code "ctx-write" %>

The following steps will be able to read the `:model` variable exactly the same way it works with `:params`.

<%= code "ctx-write-read", collapse: :body %>

Keep in mind that the above is the default behavior. You may configure what comes in and goes out of a step using [variable mapping](#activity-variable-mapping).

<%= h3 "Step" %>

An operation can be composed of any number of steps. Steps can be callable Ruby objects or instance methods of the operation itself.

<%= h4 "Instance method" %>

A step declared with a `:symbol`, as done here with `#validate`, will be considered an instance method of the operation class.

<%= code "instance-method" %>

Signature and return value are identical to all other step types.

<%= h4 "Class method" %>

A class method can come in handy if you want to reuse this particular step in an entirely different operation.

<%= code "class-method" %>

Note that the actual class method has to be defined before retrieving the method object via `method(:validate)`. Again, signature and return value are identical to other styles.

<%= h4 "Module method" %>

Just like a class method, steps can come from any module - this makes it straight-forward to create reusable chunks of logic.

<%= code "module-step" %>

The mechanics to use a "foreign" method as a step are identical to using a class method - they simply rely on [Ruby's `#method` function](https://ruby-doc.org/3.2.2/Method.html).

<%= code "module-method" %>

This is a common technique in complex Trailblazer applications for creating reusable steps with a high degree of maintainability.

<%= h4 "Callable" %>

As a matter of fact, any object, module or class exposing a `#call` method can be a step!

<%= code "callable-step" %>

Callable objects are often used when the step's logic exceeds a certain threshold of complexity and you want to introduce additional methods, as the above `#valid?` function.

<%= info do %>
Keep in mind that a step can also be implemented using a second *operation*. You can use the [`Subprocess()` macro](#activity-wiring-api-subprocess) to nest operations.
<% end -%>

<%= h4 "Lambda" %>

Another trick, mostly used for debugging, is to use a lambda as a step.

<%= code "lambda-step" %>

Obviously, this is not really sustainable and should be replaced with one of the above options.

<%= h3 "Ctx" %>

ctx#[]
keyword arguments
ctx#[]=


return value FLOW CONTROL
Signal
circuit interface

invocation
