<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
    <title>Representable - Trailblazer</title>
    <meta content="width=device-width,initial-scale=1" name="viewport"/>
    
    
    <link rel="stylesheet" href="/assets/tailwind-a6d826333e13236f7073580d8ef10b73a06a0356d808f6e415e22ba9b2a3de33.css" />
<link rel="stylesheet" href="/assets/inter-font-8c3e82affb176f4bca9616b838d906343d1251adc8408efe02cf2b1e4fcf2bc4.css" />
    <link rel="stylesheet" href="/assets/application-9915db70b6ec78b594924b5260f77917dbde4dfa05406926e8065c51138be1c6.css" />
    <script>pageIdentifier = "docs";</script>
    <script type="importmap" data-turbo-track="reload">{
  "imports": {
    "application": "/assets/application-840139e27b33cd120687852d38911c11e91b076728d40aca3b48439d857c60ad.js",
    "anchor-js": "/assets/anchor-js-821952d04abcd941bb3541822cd1c1f0234e5168bef1f9b2a050868af608aa5a.js",
    "navigations": "/assets/navigations-27f57ba888008b48256d2635e15bd2f0be7a039b32c8e84140da87596cbf9547.js",
    "docsearch": "/assets/docsearch-ec78641e626432933b5c9f60c1f9de8cf1c15c4446aa565f6b185495eed4cdb0.js",
    "highlight.js/lib/core": "/assets/highlight.js--lib--core-d83dc99104442fb344c757a56d28fa888edee01ed7e6dad88a445f7c7ec6d4c9.js",
    "highlight.js/lib/languages/ruby": "/assets/highlight.js--lib--languages--ruby-f74e4cf7cb12132c4f16865b466beac81cd62a84a8119ebf005060b9d5945175.js",
    "jquery": "/assets/jquery-9292661fe0d8c5ef2ef35f5ca64d541d70c87e9f6d7f2716d646591a295b7f36.js",
    "jquery.parallax-scroll": "/assets/jquery.parallax-scroll-a50d2125650d18a234bc9a3eea0a0f1c40871f3ccfba877d0eae70e690955825.js",
    "@docsearch/js": "https://cdn.jsdelivr.net/npm/@docsearch/js@3.5.2/dist/umd/index.min.js"
  }
}</script>
<link rel="modulepreload" href="/assets/application-840139e27b33cd120687852d38911c11e91b076728d40aca3b48439d857c60ad.js">
<link rel="modulepreload" href="/assets/anchor-js-821952d04abcd941bb3541822cd1c1f0234e5168bef1f9b2a050868af608aa5a.js">
<script src="/assets/es-module-shims.min-4ca9b3dd5e434131e3bb4b0c1d7dff3bfd4035672a5086deec6f73979a49be73.js" async="async" data-turbo-track="reload"></script>
<script type="module">import "application"</script>

    <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
  </head>
  <body>
    <nav class=" text-base z-[50] top-0 absolute w-full lg:h-[5.5rem] lg:px-[5.6rem] py-3 lg:flex lg:justify-between lg:items-center bg-white sticky" id="navbar">
  <a href="/2.1" class="block shrink-0 w-fit mx-auto lg:mx-0">
    <img class="w-40 lg:my-0" src="/assets/logo_blue_ruby-e87334a67ff20033fae8c8d2c07e549b5f1faa9b75bb07fbb2ff9d1c0dfef6e7.svg" />
  </a>
  <div class="lg:hidden absolute right-4 top-2 flex w-9 h-9 items-center" id="hamburgerIcon">
    <div class="pointer-events-none w-full h-0.5 bg-blue transition-all duration-150
                  before:content-[''] before:absolute before:w-full before:h-0.5 before:bg-blue before:-translate-y-2.5 before:transition-all before:duration-150
                  after:content-[''] after:absolute after:w-full after:h-0.5 after:bg-blue after:translate-y-2.5 after:transition-all after:duration-150"></div>
  </div>
  <div class="lg:hidden flex flex-col text-center hidden" id="navList">
    <div class="lg:absolute flex flex-col mt-15 gap-10 uppercase">
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/docs/trailblazer">Documentation</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="https://dev.to/trailblazer">Blog</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/about.html">About</a>
      
      <!-- <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/pro.html">PRO</a> -->
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="https://trailblazer.zulipchat.com">Chat with us</a>
    </div>
  </div>
  <div class="lg:flex hidden gap-10 items-center">
    <div class="flex gap-7">
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold underline decoration-[5px] underline-offset-[15px] decoration-purple hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/docs/trailblazer">Documentation</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="https://dev.to/trailblazer">Blog</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/about.html">About</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.0/">→ 2.0</a>
      
      <!-- <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/pro.html">PRO</a> -->
    </div>

    <a class="base-button text-base w-[12.5rem] h-[3.25rem] bg-light-purple text-blue hover:text-white hover:bg-purple" href="https://trailblazer.zulipchat.com">Chat with us</a>
  </div>
</nav>

<section>
  <div class="lg:hidden bg-bg-blue text-white fixed left-0 top-20 pr-1 py-3 rounded-r" id="sideNavShowButton" style="writing-mode: vertical-rl; text-orientation: upright;">
    Chapters
  </div>
  <div class="lg:flex">
    <nav class="bg-bg-blue w-screen h-screen fixed top-0 z-20 right-[100vw] overflow-y-scroll lg:w-3/12 lg:max-w-[23rem] lg:overflow-y-visible lg:shrink-0 lg:sticky lg:top-[5.5rem]" id="sideNav">
      <button class="lg:hidden absolute right-4 top-4 text-3xl text-white" id="sideNavHideButton">
        X
      </button>
      <div class="lg:pt-10 lg:pl-5 xl:pl-20 p-10 pl-20 text-white leading-10 space-y-1 h-full overflow-auto">
  


  
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/trailblazer/index.html">Trailblazer</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/operation/index.html">Operation</a>

        

          

            
              <a href="/2.1/docs/activity/deprecated/index.html" class="" title="Deprecated activity docs: :input/:output, ...">
                
                    <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512" class="fill-grey pl-3 hover:fill-purple flex-inline"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M251.7 127.6l0 0c10.5 10.5 24.7 16.4 39.6 16.4H448c8.8 0 16 7.2 16 16v32H48V96c0-8.8 7.2-16 16-16H197.5c4.2 0 8.3 1.7 11.3 4.7l33.9-33.9L208.8 84.7l42.9 42.9zM48 240H464V416c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V240zM285.7 93.7L242.7 50.7c-12-12-28.3-18.7-45.3-18.7H64C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H291.3c-2.1 0-4.2-.8-5.7-2.3z"/></svg>
                 
              </a>

            


          

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/rails_integration/index.html">Rails integration</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/test/index.html">Test</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col border-t-[1px] border-t-light-purple">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/macro/index.html">Macro</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/workflow/index.html">Workflow</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/endpoint/index.html">Endpoint</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/internals/index.html">Internals</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col border-t-[1px] border-t-light-purple">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/reform/index.html">Reform</a>

        

          

            

              <a href="/2.1/docs/reform/3.0/index.html" class="">
                <span class="h-5 text-[8pt] py-[3px] px-2 rounded-[8px] ml-3 hover:bg-purple hover:border-purple hover:text-white border border-grey text-grey">
                  3.0
                </span>
              </a>
            


          

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/cells/index.html">Cells</a>

        

          

            

              <a href="/2.1/docs/cells/5.0/index.html" class="">
                <span class="h-5 text-[8pt] py-[3px] px-2 rounded-[8px] ml-3 hover:bg-purple hover:border-purple hover:text-white border border-grey text-grey">
                  5.0
                </span>
              </a>
            


          

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class="bg-dark-purple flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/representable/index.html">Representable</a>

        
      </div>


      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-representable-api">
          <a href="#representable-api" class="pl-8">API</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-representable-function-api">
          <a href="#representable-function-api" class="pl-8">Function API</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-representable-xml">
          <a href="#representable-xml" class="pl-8">XML</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-representable-yaml">
          <a href="#representable-yaml" class="pl-8">YAML</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-representable-debugging">
          <a href="#representable-debugging" class="pl-8">Debugging</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-representable-upgrading-guide">
          <a href="#representable-upgrading-guide" class="pl-8">Upgrading Guide</a>
        </div>
      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/disposable/index.html">Disposable</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/roar/index.html">Roar</a>

        
      </div>


      
    </div>

    
  
</div>


    </nav>
    <div class="lg:p-10 pl-8 pr-4 py-10 bg-light-grey grow">
      <h1 class="lg:text-3xl text-2xl text-blue font-bold">
        <span class="py-1 px-3 border border rounded border border-white text-white bg-purple">2.1</span>
        <span class="font-black uppercase header-text">
          Representable
        </span>
        Documentation
      </h1>

      <div class="xl:flex xl:gap-0.5 mt-5">
        <div class="max-w-3xl lg:p-8 lg:pb-14 p-4 bg-white text-bg-blue space-y-9" id="documentation">
          <p class="">Representable maps objects to documents (rendering) and documents to objects (parsing) using <em>representers</em>. Representers define the document structure and the transformation to/from objects.</p>

<p class="">Representers can define deeply nested object graphs….</p>

<p class="">It is very popular amongst REST API developers as it tackles both sides of exposing APIs: rendering documents and deserializing incoming documents to object graphs using a very generic approach.</p>

<p class="">But it’s also very helpful as a generic data transformer. …</p>

<p class="">In case you’re looking towards implementing a REST API, check out <a href="/2.1/docs/roar.html" class="underline text-purple">Roar</a> first, which adds hypermedia semantics, media formats and more to Representable</p>

<h2 id="representable-api" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">API</span></h2>

<p class="">In Representable, we differentiate between three APIs.</p>

<p class="">The <a href="#representable-api" class="underline text-purple">declarative API</a> is how we define representers. You can learn how to use those representers by reading about the very brief <a href="#representable-api-public-api" class="underline text-purple">public API</a>. Representable is extendable without having to hack existing code: the <a href="#representable-function-api" class="underline text-purple">function API</a> documents how to use its options to achieve what you need.</p>

<h3 id="representable-api-declarative-api" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Declarative API</span></h3>

<p class="">To render objects to documents or parse documents to objects, you need to define a representer.</p>

<p class="">A representer can either be a class (called <em>decorator</em>) or a module (called <em>representer module</em>). Throughout the docs, we will use decorators as they are cleaner and faster, but keep in mind you can also use modules.</p>

<pre><code>require 'representable/json'

class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p class="">A representer simply defines the fields that will be mapped to the document using <code class="text-purple">property</code> or <code class="text-purple">collection</code>. You can then decorate an object and render or parse. Here’s an example.</p>

<pre><code># Given a Struct like this
Song = Struct.new(:id, :title) #=&gt; Song

# You can instantiate it with the following
song = Song.new(1, "Fallout") #=&gt; #&lt;struct Song id=1, title="Fallout"&gt;

# This object doesn't know how to represent itself in JSON
song.to_json #=&gt; NoMethodError: undefined method `to_json'

# But you can decorate it with the above defined representer
song_representer = SongRepresenter.new(song)

# Relax and let the representer do its job
song_representer.to_json #=&gt; {"id":1,"title":"Fallout"}
</code></pre>

<p class="">The details are being discussed in the <a href="#representable-api" class="underline text-purple">public API</a> section.</p>

<h3 id="representer-modules">Representer Modules</h3>

<p class="">Instead of using classes as representers, you can also leverage modules which will then get mixed into the represented object.</p>

<p class="">A representer module is also a good way to share configuration and logic across decorators.</p>

<pre><code>module SongRepresenter
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p class="">The API in a module representer is identical to decorators. However, the way you apply them is different.</p>

<pre><code>song.extend(SongRepresenter).to_json #=&gt; {"id":1,"title":"Fallout"}
</code></pre>

<p class="">There’s two drawbacks with this approach.</p>

<ol>
  <li class="list-image-disc ml-10">You pollute the represented object with the imported representer methods (e.g. <code class="text-purple">to_json</code>).</li>
  <li class="list-image-disc ml-10">Extending an object at run-time is costly and with many <code class="text-purple">extend</code>s there will be a notable performance decrease.</li>
</ol>

<p class="">Throughout this documentation, we will use decorator as examples to encourage this cleaner and faster approach.</p>

<h4 id="collections">Collections</h4>

<p class="">Not everything is a scalar value. Sometimes an object’s property can be a collection of values. Use <code class="text-purple">collection</code> to represent arrays.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
  collection :composer_ids
end
</code></pre>

<p class="">The new collection <code class="text-purple">composer_ids</code> has to be enumeratable object, like an array.</p>

<pre><code>Song = Struct.new(:id, :title, :composer_ids)
song = Song.new(1, "Fallout", [2, 3])

song_representer = SongRepresenter.new(song)
song_representer.to_json #=&gt; {"id":1,"title":"Fallout","composer_ids":[2,3]}
</code></pre>

<p class="">Of course, this works also for parsing. The incoming <code class="text-purple">composer_ids</code> will override the old collection on the represented object.</p>

<h4 id="nesting">Nesting</h4>

<p class="">Representable can also handle compositions of objects. This works for both <code class="text-purple">property</code> and <code class="text-purple">collection</code>.</p>

<p class="">For example, a song could nest an artist object.</p>

<pre><code>Song   = Struct.new(:id, :title, :artist)
Artist = Struct.new(:id, :name)

artist = Artist.new(2, "The Police")
song   = Song.new(1, "Fallout", artist)
</code></pre>

<p class="">Here’s a better view of that object graph.</p>

<pre><code>#&lt;struct Song
  id=1,
  title="Fallout",
  artist=#&lt;struct Artist
    id=2,
    name="The Police"&gt;&gt;
</code></pre>

<h4 id="inline-representer">Inline Representer</h4>

<p class="">The easiest way to nest representers is by using an inline representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title

  property :artist do
    property :id
    property :name
  end
end
</code></pre>

<p class="">Note that you can have any levels of nesting.</p>

<h4 id="explicit-representer">Explicit Representer</h4>

<p class="">Sometimes you want to compose two existing, stand-alone representers.</p>

<pre><code>class ArtistRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :name
end
</code></pre>

<p class="">To maximize reusability of representers, you can reference a nested representer using the <code class="text-purple">:decorator</code> option.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title

  property :artist, decorator: ArtistRepresenter
end
</code></pre>

<p class="">This is identical to an inline representer, but allows you to reuse <code class="text-purple">ArtistRepresenter</code> elsewhere.</p>

<p class="">Note that the <code class="text-purple">:extend</code> and <code class="text-purple">:decorator</code> options are identical. They can both reference a decorator or a module.</p>

<h4 id="nested-rendering">Nested Rendering</h4>

<p class="">Regardless of the representer types you use, rendering will result in a nested document.</p>

<pre><code>SongRepresenter.new(song).to_json
#=&gt; {"id":1,"title":"Fallout","artist":{"id":2,"name":"The Police"}}
</code></pre>

<h4 id="nested-parsing">Nested Parsing</h4>

<p class="">When parsing, per default Representable will want to instantiate an object for every nested, typed fragment.</p>

<p class="">You have to tell Representable what object to instantiate for the nested <code class="text-purple">artist:</code> fragment.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  # ..
  property :artist, decorator: ArtistRepresenter, class: Artist
end
</code></pre>

<p class="">This happens via the <code class="text-purple">:class</code> option. Now, the document can be parsed and a nested <code class="text-purple">Artist</code> will be created by the parsing.</p>

<pre><code>song = Song.new # nothing set.

SongRepresenter.new(song).
  from_json('{"id":1,"title":"Fallout","artist":{"id":2,"name":"The Police"}}')

song.artist.name #=&gt; "The Police"
</code></pre>

<p class="">The default behavior is - admittedly - very primitive. Representable’s parsing allow rich mapping, object creation and runtime checks.</p>

<h3 id="document-nesting">Document Nesting</h3>

<p class="">Not always does the structure of the desired document map to your objects. The <code class="text-purple">::nested</code> method allows structuring properties within a separate section while still mapping the properties to the outer object.</p>

<p class="">Imagine the following document.</p>

<pre><code>json_fragment = &lt;&lt;END
{"title": "Roxanne",
 "details":
   {"track": 3,
    "length": "4:10"}
}
END
</code></pre>

<p class="">However, in the <code class="text-purple">Song</code> class, there’s no such concept as <code class="text-purple">details</code>.</p>

<pre><code>Song = Struct.new(:title, :track, :length)

song = Song.new #=&gt; #&lt;struct Song title=nil, track=nil, length=nil&gt;
</code></pre>

<p class="">Both track and length are properties of the song object itself. Representable gives you ::nested to map the virtual <code class="text-purple">details</code> section to the song instance.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title

  nested :details do
    property :track
    property :length
  end
end

song_representer = SongRepresenter.new(song)
song_representer.from_json(json_fragment)
</code></pre>

<p class="">Accessors for the nested properties will still be called on the song object. And as always, this works both ways - for rendering and parsing.</p>

<h4 id="wrapping">Wrapping</h4>

<p class="">You can automatically wrap a document.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  self.representation_wrap= :song

  property :title
  property :id
end
</code></pre>

<p class="">This will add a container for rendering and parsing.</p>

<pre><code>SongRepresenter.new(song).to_json
#=&gt; {"song":{"title":"Fallout","id":1}}
</code></pre>

<p class="">Setting <code class="text-purple">self.representation_wrap = true</code> will advice representable to figure out the wrap itself by inspecting the represented object class.</p>

<p class="">Note that <code class="text-purple">representation_wrap</code> is a dynamic function option.</p>

<pre><code>self.representation_wrap = -&gt;(user_options:) { user_options[:my_wrap] }
</code></pre>

<p class="">This would allow to provide the wrap manually.</p>

<pre><code>song_representer.to_json(user_options: { my_wrap: "hit" })
</code></pre>

<h4 id="suppressing-nested-wraps">Suppressing Nested Wraps</h4>

<p class="">When reusing a representer for a nested document, you might want to suppress its <code class="text-purple">representation_wrap=</code> for the nested fragment.</p>

<p class="">Reusing <code class="text-purple">SongRepresenter</code> from the last section in a nested setup allows suppressing the wrap via the <code class="text-purple">:wrap</code> option.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::JSON

  collection :songs,
    decorator: SongRepresenter, # SongRepresenter defines representation_wrap.
    wrap:      false            # turn off :song wrap.
end
</code></pre>

<p class="">The <code class="text-purple">representation_wrap</code> from the nested representer now won’t be rendered or parsed…</p>

<pre><code>Album = Struct.new(:songs)
album = Album.new
album.songs = [song]
AlbumRepresenter.new(album).to_json
</code></pre>

<p class="">.. and will result in:</p>

<pre><code class="language-json">{"songs":[{"title":"Fallout","id":1}]}
</code></pre>

<p class="">Otherwise it would respect the <code class="text-purple">representation_wrap=</code> set in the nested decorator (SongRepresenter) and will render:</p>

<pre><code class="language-json">{"songs":[{"song":{"title":"Fallout","id":1}}]}
</code></pre>

<p class="">Note that this only works for JSON and Hash at the moment.</p>

<h4 id="inheritance">Inheritance</h4>

<p class="">Properties can be inherited across representer classes and modules.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :id
  property :title
end
</code></pre>

<p class="">What if you need a refined representer to also add the artist. Use inheritance.</p>

<pre><code>class SongWithArtistRepresenter &lt; SongRepresenter
  property :artist do
    property :name
  end
end
</code></pre>

<p class="">All configuration from <code class="text-purple">SongRepresenter</code> will be inherited, making the properties on <code class="text-purple">SongWithArtistRepresenter</code>: <code class="text-purple">id</code>, <code class="text-purple">title</code>, and <code class="text-purple">artist</code>. The original <code class="text-purple">SongRepresenter</code> will stay as it is.</p>

<pre><code>Artist         = Struct.new(:name)
SongWithArtist = Struct.new(:id, :title, :artist)

artist           = Artist.new("Ivan Lins")
song_with_artist = SongWithArtist.new(1, "Novo Tempo", artist)

# Using the same object with the two representers
song_representer             = SongRepresenter.new(song_with_artist)
song_with_artist_representer = SongWithArtistRepresenter.new(song_with_artist)

song_representer.to_json
#=&gt; {"id":1,"title":"Novo Tempo"}

song_with_artist_representer.to_json
#=&gt; {"id":1,"title":"Novo Tempo","artist":{"name":"Ivan Lins"}}
</code></pre>

<h4 id="composition">Composition</h4>

<p class="">You can also use modules and decorators together to compose representers.</p>

<pre><code>module GenericRepresenter
  include Representable::JSON

  property :id
end
</code></pre>

<p class="">This can be included in other representers and will extend their configuration.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include GenericRepresenter

  property :title
end
</code></pre>

<p class="">As a result, <code class="text-purple">SongRepresenter</code> will contain the good old <code class="text-purple">id</code> and <code class="text-purple">title</code> property.</p>

<h4 id="overriding-properties">Overriding Properties</h4>

<p class="">You might want to override a particular property in an inheriting representer. Successively calling <code class="text-purple">property(name)</code> will override the former definition - exactly as you know it from overriding methods in Ruby.</p>

<pre><code>class CoverSongRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :title, as: :name # overrides that definition.
end
</code></pre>

<h4 id="partly-overriding-properties">Partly Overriding Properties</h4>

<p class="">Instead of fully replacing a property, you can extend it with <code class="text-purple">:inherit</code>. This will <em>add</em> your new options and override existing options in case the one you provided already existed.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title, as: :name, render_nil: true
end
</code></pre>

<p class="">You can now inherit properties but still override or add options.</p>

<pre><code>class CoverSongRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :title, as: :songTitle, default: "n/a", inherit: true
end
</code></pre>

<p class="">Using the :inherit, this will result in a property having the following options.</p>

<pre><code>property :title,
  as:         :songTitle, # overridden in CoverSongRepresenter.
  render_nil: true        # inherited from SongRepresenter.
  default:    "n/a"       # defined in CoverSongRepresenter.
</code></pre>

<p class="">The <code class="text-purple">:inherit</code> option works for both inheritance and module composition.</p>

<h4 id="inherit-with-inline-representers">Inherit With Inline Representers</h4>

<p class=""><code class="text-purple">:inherit</code> also works applied with inline representers.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  property :title
  property :artist do
    property :name
  end
end
</code></pre>

<p class="">You can now override or add properties within the inline representer.</p>

<pre><code>class HitRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :artist, inherit: true do
    property :email
  end
end
</code></pre>

<p class="">Results in a combined inline representer as it inherits.</p>

<pre><code>property :artist do
  property :name
  property :email
end
</code></pre>

<p class="">Naturally, <code class="text-purple">:inherit</code> can be used within the inline representer block.</p>

<p class="">Note that the following also works.</p>

<pre><code>class HitRepresenter &lt; SongRepresenter
  include Representable::JSON

  property :artist, as: :composer, inherit: true
end
</code></pre>

<p class="">This renames the property but still inherits all the inlined configuration.</p>

<p class="">Basically, <code class="text-purple">:inherit</code> copies the configuration from the parent property, then merges in your options from the inheriting representer. It exposes the same behaviour as <code class="text-purple">super</code> in Ruby - when using <code class="text-purple">:inherit</code> the property must exist in the parent representer.</p>

<h3 id="representable-api-feature" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Feature</span></h3>

<p class="">If you need to include modules in all inline representers automatically, register it as a feature.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::JSON
  feature Link # imports ::link

  link "/album/1"

  property :hit do
    link "/hit/1" # link method imported automatically.
  end
end
</code></pre>

<p class="">Nested representers will <code class="text-purple">include</code> the provided module automatically.</p>

<h3 id="representable-api-execution-context" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Execution Context</span></h3>

<p class="">Readers and Writers for properties will usually be called on the <code class="text-purple">represented</code> object. If you want to change that, so the accessors get called on the decorator instead, use <code class="text-purple">:exec_context</code>.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  property :title, exec_context: :decorator

  def title
    represented.name
  end
end
</code></pre>

<h3 id="representable-api-callable-options" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Callable Options</span></h3>

<p class="">While lambdas are one option for dynamic options, you might also pass a “callable” object to a directive.</p>

<pre><code>class Sanitizer
  include Uber::Callable

  def call(represented, fragment, doc, *args)
    fragment.sanitize
  end
end
</code></pre>

<p class="">Note how including <code class="text-purple">Uber::Callable</code> marks instances of this class as callable. No <code class="text-purple">respond_to?</code> or other magic takes place here.</p>

<pre><code>property :title, parse_filter: Santizer.new
</code></pre>

<p class="">This is enough to have the <code class="text-purple">Sanitizer</code> class run with all the arguments that are usually passed to the lambda (preceded by the represented object as first argument).</p>

<h3 id="representable-api-read-write-restrictions" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Read/Write Restrictions</span></h3>

<p class="">Using the <code class="text-purple">:readable</code> and <code class="text-purple">:writeable</code> options access to properties can be restricted.</p>

<pre><code>property :title, readable: false
</code></pre>

<p class="">This will leave out the <code class="text-purple">title</code> property in the rendered document. Vice-versa, <code class="text-purple">:writeable</code> will skip the property when parsing and does not assign it.</p>

<h3 id="representable-api-coercion" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Coercion</span></h3>

<p class="">If you need coercion when parsing a document you can use the Coercion module which uses <a href="https://github.com/solnic/virtus" class="underline text-purple">virtus</a> for type conversion.</p>

<p class="">Include Virtus in your Gemfile, first.</p>

<pre><code>gem 'virtus', "&gt;= 0.5.0"
</code></pre>

<p class="">Use the <code class="text-purple">:type</code> option to specify the conversion target. Note that <code class="text-purple">:default</code> still works.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON
  include Representable::Coercion

  property :recorded_at, type: DateTime, default: "May 12th, 2012"
end
</code></pre>

<p class="">Coercing values only happens when rendering or parsing a document. Representable does not create accessors in your model as <code class="text-purple">virtus</code> does.</p>

<p class="">Note that we think coercion in the representer is wrong, and should happen on the underlying object. We have a rich <a href="/2.1/docs/disposable.html#disposable-twin-api-coercion" class="underline text-purple">coercion/constraint API for twins</a>.</p>

<h3 id="representable-api-symbol-keys" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Symbol Keys</span></h3>

<p class="">When parsing, Representable reads properties from hashes using their string keys.</p>

<pre><code>song.from_hash("title" =&gt; "Road To Never")
</code></pre>

<p class="">To allow symbol keys also include the <code class="text-purple">AllowSymbols</code> module.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::Hash
  include Representable::Hash::AllowSymbols
  # ..
end
</code></pre>

<p class="">This will give you a behavior close to Rails’ <code class="text-purple">HashWithIndifferentAccess</code> by stringifying the incoming hash internally.</p>

<h3 id="representable-api-defaults" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Defaults</span></h3>

<p class="">The <code class="text-purple">defaults</code> method allows setting options that will be applied to all property definitions of a representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults render_nil: true

  property :id
  property :title
end
</code></pre>

<p class="">This will include <code class="text-purple">render_nil: true</code> in both <code class="text-purple">id</code> and <code class="text-purple">title</code> definitions, as if you’d provided that option each time.</p>

<p class="">You can also have dynamic option computation at compile-time.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults do |name, options|
    { as: name.camelize }
  end
</code></pre>

<p class="">The <code class="text-purple">options</code> hash combines the user’s and Representable computed options.</p>

<pre><code>property :id, skip: true

defaults do |name, options|
  options[:skip] ? { as: name.camelize } : {}
end
</code></pre>

<p class="">Note that the dynamic <code class="text-purple">defaults</code> block always has to return a hash.</p>

<p class="">Combining those two forms also works.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON

  defaults render_nil: true do |name|
    { as: name.camelize }
  end
</code></pre>

<p class="">All defaults are inherited to subclasses or including modules.</p>

<h3 id="representable-api-standalone-hash" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Standalone Hash</span></h3>

<p class="">If it’s required to represent a bare hash object, use <code class="text-purple">Representable::JSON::Hash</code> instead of <code class="text-purple">Representable::JSON</code>.</p>

<p class="">This is sometimes called a <em>lonely hash</em>.</p>

<pre><code>require "representable/json/hash"

class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Hash
end
</code></pre>

<p class="">You can then use this hash decorator on instances of <code class="text-purple">Hash</code>.</p>

<pre><code>hash = {"Nick" =&gt; "Hyper Music", "El" =&gt; "Blown In The Wind"}
SongsRepresenter.new(hash).to_json
#=&gt; {"Nick":"Hyper Music","El":"Blown In The Wind"}
</code></pre>

<p class="">This works both ways.</p>

<p class="">A lonely hash starts to make sense especially when the values are nested objects that need to be represented, too. You can configure the nested value objects using the <code class="text-purple">values</code> method. This works exactly as if you were defining an inline representer, accepting the same options.</p>

<pre><code>class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Hash

  values class: Song do
    property :title
  end
end
</code></pre>

<p class="">You can now represents nested objects in the hash, both rendering and parsing-wise.</p>

<pre><code>hash = {"Nick" =&gt; Song.new("Hyper Music")}
SongsRepresenter.new(hash).to_json
</code></pre>

<p class="">In XML, use <code class="text-purple">XML::Hash</code>. If you want to store hash attributes in tag attributes instead of dedicated nodes, use <code class="text-purple">XML::AttributeHash</code>.</p>

<h3 id="representable-api-standalone-collection" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Standalone Collection</span></h3>

<p class="">Likewise, you can represent <em>lonely collections</em>, instances of <code class="text-purple">Array</code>.</p>

<pre><code>require "representable/json/collection"

class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON::Collection

  items class: Song do
    property :title
  end
end
</code></pre>

<p class="">Here, you define how to represent items in the collection using <code class="text-purple">items</code>.</p>

<p class="">Note that the items can be simple scalar values or deeply nested objects.</p>

<pre><code>ary = [Song.new("Hyper Music"), Song.new("Screenager")]
SongsRepresenter.new(ary).to_json
#=&gt; [{"title":"Hyper Music"},{"title":"Screenager"}]
</code></pre>

<p class="">Note that this also works for XML.</p>

<h3 id="representable-api-standalone-collection-to_a" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Standalone Collection: to_a</span></h3>

<p class="">Another trick to represent collections is using a normal representer with exactly one collection property named <code class="text-purple">to_a</code>.</p>

<pre><code>class SongsRepresenter &lt; Representable::Decorator
  include Representable::JSON # note that this is a plain representer.

  collection :to_a, class: Song do
    property :title
  end
end
</code></pre>

<p class="">You can use this representer the way you already know and appreciate, but directly on an array.</p>

<pre><code>ary = []
SongsRepresenter.new(ary).from_json('[{"title": "Screenager"}]')
</code></pre>

<p class="">In order to grab the collection for rendering or parsing, Representable will now call <code class="text-purple">array.to_a</code>, which returns the array itself.</p>

<h3 id="representable-api-automatic-collection-representer" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Automatic Collection Representer</span></h3>

<p class="">Instead of explicitly defining representers for collections using a <a href="#representable-api-standalone-collection" class="underline text-purple">“lonely collection”</a>, you can let Representable  do that for you.</p>

<p class="">You define a singular representer, Representable will infer the collection representer.</p>

<p class="">Rendering a collection of objects comes for free, using <code class="text-purple">for_collection</code>.</p>

<pre><code>songs = Song.all
SongRepresenter.for_collection.new(songs).to_json
#=&gt; '[{"title": "Sevens"}, {"title": "Eric"}]'
</code></pre>

<p class=""><code class="text-purple">SongRepresenter.for_collection</code> will return a collection representer class.</p>

<p class="">For parsing, you need to provide the class for the nested items. This happens via <code class="text-purple">collection_representer</code> in the representer class.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::JSON
  property :title

  collection_representer class: Song
end
</code></pre>

<p class="">You can now parse collections to <code class="text-purple">Song</code> instances.</p>

<pre><code>json  = '[{"title": "Sevens"}, {"title": "Eric"}]'

SongRepresenter.for_collection.new([]).from_json(json)
</code></pre>

<p class="">Note: the implicit collection representer internally is implemented using a lonely collection. Everything you pass to <code class="text-purple">::collection_representer</code> is simply provided to the <code class="text-purple">::items</code> call in the lonely collection. That allows you to use <code class="text-purple">:populator</code> and all the other goodies, too.</p>

<h3 id="representable-api-automatic-singular-and-collection" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Automatic Singular and Collection</span></h3>

<p class="">In case you don’t want to know whether or not you’re working with a collection or singular model, use <code class="text-purple">represent</code>.</p>

<pre><code># singular
SongRepresenter.represent(Song.find(1)).to_json
#=&gt; '{"title": "Sevens"}'

# collection
SongRepresenter.represent(Song.all).to_json
#=&gt; '[{"title": "Sevens"}, {"title": "Eric"}]'
</code></pre>

<p class=""><code class="text-purple">represent</code> figures out the correct representer for you. This works for parsing, too.</p>

<h3 id="representable-api-public-api" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Public API</span></h3>

<p class="">When decorating an object with a representer, the object needs to provide readers for every defined <code class="text-purple">property</code> - and writers, if you’re planning to parse.</p>

<h4 id="accessors">Accessors</h4>

<p class="">In our small <code class="text-purple">SongRepresenter</code> example, the represented object has to provide <code class="text-purple">#id</code> and <code class="text-purple">#title</code> for rendering.</p>

<pre><code>Song = Struct.new(:id, :title)
song = Song.new(1, "Fallout")
</code></pre>

<h4 id="rendering">Rendering</h4>

<p class="">You can render the document by decorating the object and calling the serializer method.</p>

<pre><code>SongRepresenter.new(song).to_json #=&gt; {"id":1, title":"Fallout"}
</code></pre>

<p class="">When rendering, the document fragment is read from the represented object using the getter (e.g. <code class="text-purple">Song#id</code>).</p>

<p class="">Since we use <code class="text-purple">Representable::JSON</code> the serializer method is <code class="text-purple">#to_json</code>.</p>

<p class="">For other format engines the serializer method will have the following name.</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10"><code class="text-purple">Representable::JSON#to_json</code></li>
  <li class="list-image-disc ml-10"><code class="text-purple">Representable::JSON#to_hash</code> (provides a hash instead of string)</li>
  <li class="list-image-disc ml-10"><code class="text-purple">Representable::Hash#to_hash</code></li>
  <li class="list-image-disc ml-10"><code class="text-purple">Representable::XML#to_xml</code></li>
  <li class="list-image-disc ml-10"><code class="text-purple">Representable::YAML#to_yaml</code></li>
</ul>

<h4 id="parsing">Parsing</h4>

<p class="">Likewise, parsing will read values from the document and write them to the represented object.</p>

<pre><code>song = Song.new
SongRepresenter.new(song).from_json('{"id":1, "title":"Fallout"}')
song.id    #=&gt; 1
song.title #=&gt; "Fallout"
</code></pre>

<p class="">When parsing, the read fragment is written to the represented object using the setter (e.g. <code class="text-purple">Song#id=</code>).</p>

<p class="">For other format engines, the deserializing method is named analogue to the serializing counterpart, where <code class="text-purple">to</code> becomes <code class="text-purple">from</code>. For example, <code class="text-purple">Representable::XML#from_xml</code> will parse XML if the format engine is mixed into the representer.</p>

<h4 id="user-options">User Options</h4>

<p class="">You can provide options when representing an object using the <code class="text-purple">user_options:</code> option.</p>

<pre><code>song_representer.to_json(user_options: { is_admin: true })
</code></pre>

<p class="">Note that the <code class="text-purple">:user_options</code> will be accessible on all levels in a nested representer. They act like a “global” configuration and are passed to all option functions.</p>

<p class="">Here’s an example where the <code class="text-purple">:if</code> option function evaluates a dynamic user option.</p>

<pre><code>property :id, if: -&gt;(options) { options[:user_options][:is_admin] }
</code></pre>

<p class="">This property is now only rendered or parsed when <code class="text-purple">:is_admin</code> is true.</p>

<p class="">Using Ruby 2.1’s keyword arguments is highly recommended - to make that look a bit nicer.</p>

<pre><code>property :id, if: -&gt;(user_options:, **) { user_options[:is_admin] }
</code></pre>

<h4 id="nested-user-options">Nested User Options</h4>

<p class="">Representable also allows passing nested options to particular representers. You have to provide the property’s name to do so.</p>

<pre><code>song_representer.to_json(artist: { user_options: { is_admin: true } })
</code></pre>

<p class="">This will pass the option to the nested <code class="text-purple">artist</code>, only. Note that this works with any level of nesting.</p>

<h4 id="include-and-exclude">Include and Exclude</h4>

<p class="">Representable supports two top-level options.</p>

<p class=""><code class="text-purple">:include</code> allows defining a set of properties to represent. The remaining will be skipped.</p>

<pre><code>song_representer.to_json(include: [:id])  #=&gt; {"id":1}
</code></pre>

<p class="">The other, <code class="text-purple">:exclude</code>, will - you might have guessed it already - skip the provided properties and represent the remaining.</p>

<pre><code>song_representer.to_json(exclude: [:id, :artist])
#=&gt; {"title":"Fallout"}
</code></pre>

<p class="">As always, these options work both ways, for rendering <em>and</em> parsing.</p>

<p class="">Note that you can also nest <code class="text-purple">:include</code> and <code class="text-purple">:exclude</code>.</p>

<pre><code>song_representer.to_json(artist: { include: [:name] })
#=&gt; {"id":1, "title":"Fallout", "artist":{"name":"Sting"}}
</code></pre>

<h4 id="tohash-and-fromhash">to_hash and from_hash</h4>

<h2 id="representable-function-api" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Function API</span></h2>

<p class="">Both rendering and parsing have a rich API that allows you to hook into particular steps and change behavior.</p>

<p class="">If that still isn’t enough, you can create your own pipeline.</p>

<h3 id="representable-function-api-overview" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Overview</span></h3>

<p class="">Function option are passed to <code class="text-purple">property</code>.</p>

<pre><code class="language-ruby">property :id, default: "n/a"
</code></pre>

<p class="">Most options accept a static value, like a string, or a dynamic lambda.</p>

<pre><code class="language-ruby">property :id, if: -&gt;(options) { options[:fragment].nil? }
</code></pre>

<p class="">The <code class="text-purple">options</code> hash is passed to <strong>all options</strong> and has the following members.</p>

<pre><code>{doc: doc, options: options, represented: represented, decorator: self}

options[:doc] | When rendering, the document as it gets created. When parsing, the entire document.
options[:fragment] | When parsing, this is the fragment read from the document corresponding to this property.
options[:input] | When rendering, this is the value read from the represented object corresponding to this property.
options[:represented] | The currently represented object.
options[:decorator] | The current decorator instance.
options[:binding] | The current binding instance. This allows to access the currently used definition, e.g. `options[:binding][:name]`.
options[:options] | All options that have been passed into the render or parse method.
options[:user_options] | The `:user_options` for the current representer. These are only the [nested options](#nested-user-options) from the user, for a particular representer.
</code></pre>

<p class="">In your option function, you can either receive the entire options hash and use it in the block.</p>

<pre><code class="language-ruby">if: -&gt;(options) { options[:fragment].nil? }
</code></pre>

<p class="">Or, and that is the preferred way, use Ruby’s keyword arguments.</p>

<pre><code class="language-ruby">if: -&gt;(fragment:, **) { fragment.nil? }
</code></pre>

<h3 id="representable-function-api-options" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Options</span></h3>

<p class="">Here’s a list of all available options.</p>

<table>
  <tbody>
    <tr>
      <td><code class="text-purple">:as</code></td>
      <td><a href="#representable-function-api-as" class="underline text-purple">Renames</a> property</td>
    </tr>
    <tr>
      <td><code class="text-purple">:getter</code></td>
      <td>Custom <a href="#representable-function-api-getter" class="underline text-purple">getter</a> logic for rendering</td>
    </tr>
    <tr>
      <td><code class="text-purple">:setter</code></td>
      <td>Custom <a href="#representable-function-api-setter" class="underline text-purple">setter</a> logic after parsing</td>
    </tr>
    <tr>
      <td><code class="text-purple">:if</code></td>
      <td><a href="#representable-function-api-if" class="underline text-purple">Includes</a> property when rendering/parsing when evaluated to true</td>
    </tr>
    <tr>
      <td><code class="text-purple">:reader</code></td>
      <td>Overrides entire <a href="#representable-function-api-reader" class="underline text-purple">parsing</a> process for property</td>
    </tr>
    <tr>
      <td><code class="text-purple">:writer</code></td>
      <td>Overrides entire <a href="#representable-function-api-writer" class="underline text-purple">rendering</a> process for property</td>
    </tr>
    <tr>
      <td><code class="text-purple">:skip_parse</code></td>
      <td><a href="#representable-function-api-skip-parse" class="underline text-purple">Skips parsing</a> when evaluated to true</td>
    </tr>
    <tr>
      <td><code class="text-purple">:skip_render</code></td>
      <td><a href="#representable-function-api-skip-render" class="underline text-purple">Skips rendering</a> when evaluated to true</td>
    </tr>
    <tr>
      <td><code class="text-purple">:parse_filter</code></td>
      <td>Pipeline to process <a href="#representable-function-api-parse-filter" class="underline text-purple">parsing result</a></td>
    </tr>
    <tr>
      <td><code class="text-purple">:render_filter</code></td>
      <td>Pipeline to process <a href="#representable-function-api-render-filter" class="underline text-purple">rendering result</a></td>
    </tr>
    <tr>
      <td><code class="text-purple">:deserialize</code></td>
      <td>Override <a href="#representable-function-api-deserialize" class="underline text-purple">deserialization</a> of nested object</td>
    </tr>
    <tr>
      <td><code class="text-purple">:serialize</code></td>
      <td>Override <a href="#representable-function-api-serialize" class="underline text-purple">serialization</a> of nested object</td>
    </tr>
    <tr>
      <td><code class="text-purple">:extend</code></td>
      <td><a href="#representable-function-api-extend" class="underline text-purple">Representer</a> to use for parsing or rendering</td>
    </tr>
    <tr>
      <td><code class="text-purple">:prepare</code></td>
      <td><a href="#representable-function-api-prepare" class="underline text-purple">Decorate</a> the represented object</td>
    </tr>
    <tr>
      <td><code class="text-purple">:class</code></td>
      <td><a href="#representable-function-api-class" class="underline text-purple">Class</a> to instantiate when parsing nested fragment</td>
    </tr>
    <tr>
      <td><code class="text-purple">:instance</code></td>
      <td><a href="#representable-function-api-class" class="underline text-purple">Instantiate</a> object directly when parsing nested fragment</td>
    </tr>
    <tr>
      <td><code class="text-purple">:render_nil</code></td>
      <td><a href="#representable-function-api-render-nil" class="underline text-purple">Render nil</a> values</td>
    </tr>
    <tr>
      <td><code class="text-purple">:render_empty</code></td>
      <td><a href="#representable-function-api-render-empty" class="underline text-purple">Render empty </a> collections</td>
    </tr>
  </tbody>
</table>

<h3 id="representable-function-api-as" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">As</span></h3>

<p class="">If your property name doesn’t match the name in the document, use the :as option.</p>

<pre><code class="language-ruby">property :title, as: :name
</code></pre>

<p class="">This will render using the <code class="text-purple">:as</code> value. Vice-versa for parsing</p>

<pre><code class="language-ruby">song.to_json #=&gt; {"name":"Fallout","track":1}
</code></pre>

<h3 id="representable-function-api-getter" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Getter</span></h3>

<p class="">When rendering, Representable calls the property’s getter on the represented object. For a property named <code class="text-purple">:id</code>, this will result in <code class="text-purple">represented.id</code> to retrieve the value for rendering.</p>

<p class="">You can override this, and instead of having Representable call the getter, run your own logic.</p>

<pre><code class="language-ruby">property :id, getter: -&gt;(represented:, **) { represented.uuid.human_readable }
</code></pre>

<p class="">In the rendered document, you will find the UUID now where should be the ID.</p>

<pre><code class="language-ruby">decorator.to_json #=&gt; {"id": "f81d4fae-7dec-11d0-a765-00a0c91e6bf6"}
</code></pre>

<p class="">As helpful as this option is, please do not overuse it. A representer is not a data mapper, but a document transformer. If your underlying data model and your representers diverge too much, consider using a <a href="/2.1/docs/disposable.html" class="underline text-purple">twin</a> to simplify the representer.</p>

<h3 id="representable-function-api-setter" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Setter</span></h3>

<p class="">After parsing has happened, the fragment is assigned to the represented object using the property’s setter. In the above example, Representable will call <code class="text-purple">represented.id=(fragment)</code>.</p>

<p class="">Override that using <code class="text-purple">:setter</code>.</p>

<pre><code class="language-ruby">property :id,
  setter: -&gt;(fragment:, represented:, **) { represented.uuid = fragment.upcase }
</code></pre>

<p class="">Again, don’t overuse this method and consider a twin if you find yourself using <code class="text-purple">:setter</code> for every property.</p>

<h3 id="representable-function-api-if" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">If</span></h3>

<p class="">You can exclude properties when rendering or parsing, as if they were not defined at all. This works with <code class="text-purple">:if</code>.</p>

<pre><code class="language-ruby">property :id, if: -&gt;(user_options:,**) { user_options[:is_admin] }
</code></pre>

<p class="">When parsing (or rendering), the <code class="text-purple">id</code> property is only considered when <code class="text-purple">is_admin</code> has been passed in.</p>

<p class="">This will parse the <code class="text-purple">id</code> field.</p>

<pre><code class="language-ruby">decorator.from_json('{"id":1}', user_options: {is_admin: true})
</code></pre>

<h3 id="representable-function-api-reader" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Reader</span></h3>

<p class="">To override the entire parsing process, use <code class="text-purple">:reader</code>. You won’t have access to <code class="text-purple">:fragment</code> here since parsing hasn’t happened, yet.</p>

<pre><code class="language-ruby">property :id,
  reader: -&gt;(represented:,doc:,**) { represented.payload = doc[:uuid] || "n/a" }
</code></pre>

<p class="">With <code class="text-purple">:reader</code>, parsing is completely up to you. Representable will only invoke the function and do nothing else.</p>

<h3 id="representable-function-api-writer" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Writer</span></h3>

<p class="">To override the entire rendering process, use <code class="text-purple">:writer</code>. You won’t have access to <code class="text-purple">:input</code> here since the value query to the represented object hasn’t happened, yet.</p>

<pre><code class="language-ruby">property :id,
  writer: -&gt;(represented:,doc:,**) { doc[:uuid] = represented.id }
</code></pre>

<p class="">With <code class="text-purple">:writer</code>, rendering is completely up to you. Representable will only invoke the function and do nothing else.</p>

<h3 id="representable-function-api-skip-parse" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Skip Parse</span></h3>

<p class="">To suppress parsing of a property, use <code class="text-purple">:skip_parse</code>.</p>

<pre><code class="language-ruby">property :id,
  skip_parse: -&gt;(fragment:,**) { fragment.nil? || fragment=="" }
</code></pre>

<p class="">No further processing happens with this property, should the option evaluate to true.</p>

<h3 id="representable-function-api-skip-render" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Skip Render</span></h3>

<p class="">To suppress rendering of a property, use <code class="text-purple">:skip_render</code>.</p>

<pre><code class="language-ruby">property :id,
  skip_render: -&gt;(represented:,**) { represented.id.nil? }
</code></pre>

<p class="">No further processing happens with this property, should the option evaluate to true.</p>

<h3 id="representable-function-api-parse-filter" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Parse Filter</span></h3>

<p class="">Use <code class="text-purple">:parse_filter</code> to process the parsing result.</p>

<pre><code class="language-ruby">property :id,
  parse_filter: -&gt;(fragment, options) { fragment.strip }
</code></pre>

<p class="">Just before setting the fragment to the object via the setter, the <code class="text-purple">:parse_filter</code> is called.</p>

<p class="">Note that you can add multiple filters, the result from the last will be passed to the next.</p>

<h3 id="representable-function-api-render-filter" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Render Filter</span></h3>

<p class="">Use <code class="text-purple">:render_filter</code> to process the rendered fragment.</p>

<pre><code class="language-ruby">property :id,
  render_filter: -&gt;(input, options) { input.strip }
</code></pre>

<p class="">Just before rendering the fragment into the document, the <code class="text-purple">:render_filter</code> is invoked.</p>

<p class="">Note that you can add multiple filters, the result from the last will be passed to the next.</p>

<h3 id="representable-function-api-deserialize" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Deserialize</span></h3>

<p class="">When deserializing a nested fragment, the default mechanics after decorating the represented object are to call <code class="text-purple">represented.from_json(fragment)</code>.</p>

<p class="">Override this step using <code class="text-purple">:deserialize</code>.</p>

<pre><code class="language-ruby">property :artist,
  deserialize: -&gt;(input:,fragment:,**) { input.attributes = fragment }
</code></pre>

<p class="">The <code class="text-purple">:input</code> option provides the currently deserialized object.</p>

<h3 id="representable-function-api-serialize" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Serialize</span></h3>

<p class="">When serializing a nested object, the default mechanics after decorating the represented object are to call <code class="text-purple">represented.to_json</code>.</p>

<p class="">Override this step using <code class="text-purple">:serialize</code>.</p>

<pre><code class="language-ruby">property :artist,
  serialize: -&gt;(represented:,**) { represented.attributes.to_h }
</code></pre>

<h3 id="representable-function-api-extend" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Extend</span></h3>

<p class="">Alias: <code class="text-purple">:decorator</code>.</p>

<p class="">When rendering or parsing a nested object, that represented object needs to get decorated, which is configured via the <code class="text-purple">:extend</code> option.</p>

<p class="">You can use <code class="text-purple">:extend</code> to configure an explicit representer module or decorator.</p>

<pre><code class="language-ruby">property :artist, extend: ArtistRepresenter
</code></pre>

<p class="">Alternatively, you could also compute that representer at run-time.</p>

<p class="">For parsing, this could look like this.</p>

<pre><code class="language-ruby">property :artist,
  extend: -&gt;(fragment:,**) do
    fragment["type"] == "rockstar" ? RockstarRepresenter : ArtistRepresenter
  end
</code></pre>

<p class="">For rendering, you could do something as follows.</p>

<pre><code class="language-ruby">property :artist,
  extend: -&gt;(input:,**) do
    input.is_a?(Rockstar) ? RockstarRepresenter : ArtistRepresenter
  end
</code></pre>

<p class="">This allows a dynamic polymorphic representer structure.</p>

<h3 id="representable-function-api-prepare" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Prepare</span></h3>

<p class="">The default mechanics when representing a nested object is decorating the object, then calling the serializer or deserializer method on it.</p>

<p class="">You can override this step using <code class="text-purple">:prepare</code>.</p>

<pre><code class="language-ruby">property :artist,
  prepare: -&gt;(represented:,**) { ArtistRepresenter.new(input) }
</code></pre>

<p class="">Just for fun, you could mimic the original behavior.</p>

<pre><code class="language-ruby">property :artist,
  prepare: -&gt;(represented:,binding:,**) { binding[:extend].new(represented) }
</code></pre>

<h3 id="representable-function-api-class" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Class</span></h3>

<p class="">When parsing a nested fragment, Representable per default creates an object for you. The class can be defined with <code class="text-purple">:class</code>.</p>

<pre><code class="language-ruby">property :artist,
  class: Artist
</code></pre>

<p class="">It could also be dynamic.</p>

<pre><code class="language-ruby">property :artist,
  class: -&gt;(fragment) { fragment["type"] == "rockstar" ? Rockstar : Artist }
</code></pre>

<h3 id="representable-function-api-instance" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Instance</span></h3>

<p class="">Instead of using <code class="text-purple">:class</code> you can directly instantiate the represented object yourself using <code class="text-purple">:instance</code>.</p>

<pre><code class="language-ruby">property :artist,
  instance: -&gt;(fragment) do
    fragment["type"] == "rockstar" ? Rockstar.new : Artist.new
  end
</code></pre>

<h3 id="representable-function-api-render-nil" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Render Nil</span></h3>

<p class="">In Representable, <code class="text-purple">false</code> values are considered as a valid value and will be rendered into the document or parsed.</p>

<p class="">If you want <code class="text-purple">nil</code> values to be included when rendering, use the <code class="text-purple">:render_nil</code> option.</p>

<pre><code class="language-ruby">property :title,
  render_nil: true
</code></pre>

<h3 id="representable-function-api-render-empty" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Render Empty</span></h3>

<p class="">Per default, empty collections are rendered (unless they’re <code class="text-purple">nil</code>). You can suppress rendering.</p>

<pre><code class="language-ruby">collection :songs,
  render_empty: false
</code></pre>

<h2 id="representable-xml" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">XML</span></h2>

<p class="">If you’re enjoying the pleasure of working with XML, Representable can help you. It does render and parse XML, too, with an almost identical declarative API.</p>

<pre><code>require "representable/xml"

class SongRepresenter &lt; Representable::Decorator
  include Representable::XML

  property :title
  collection :composers
end
</code></pre>

<p class="">Note that you have to include the <code class="text-purple">Representable::XML</code> module.</p>

<p class="">The public API then gives you <code class="text-purple">to_xml</code> and <code class="text-purple">from_xml</code>.</p>

<pre><code class="language-ruby">Song = Struct.new(:title, :composers)
song = Song.new("Fallout", ["Stewart Copeland", "Sting"])
SongRepresenter.new(song).to_xml
</code></pre>

<pre><code class="language-xml">&lt;song&gt;
  &lt;title&gt;Fallout&lt;/title&gt;
  &lt;composers&gt;Stewart Copeland&lt;/composers&gt;
  &lt;composers&gt;Sting&lt;/composers&gt;
&lt;/song&gt;
</code></pre>

<h3 id="representable-xml-tag-attributes" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Tag Attributes</span></h3>

<p class="">You can also map properties to tag attributes in Representable. This works only for the top-level node, though (seen from the representer’s perspective).</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::XML

  property :title, attribute: true
  collection :composers
end

SongRepresenter.new(song).to_xml
</code></pre>

<pre><code class="language-xml">&lt;song title="Fallout"&gt;
  &lt;composers&gt;Stewart Copeland&lt;/composers&gt;
  &lt;composers&gt;Sting&lt;/composers&gt;
&lt;/song&gt;
</code></pre>

<p class="">Naturally, this works both ways.</p>

<h3 id="representable-xml-mapping-content" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Mapping Content</span></h3>

<p class="">The same concept can also be applied to content. If you need to map a property to the top-level node’s content, use the <code class="text-purple">:content</code> option. Again, <em>top-level</em> refers to the document fragment that maps to the representer.</p>

<pre><code>class SongRepresenter &lt; Representable::Decorator
  include Representable::XML

  property :title, content: true
end

SongRepresenter.new(song).to_xml
</code></pre>

<pre><code class="language-xml">&lt;song&gt;Fallout&lt;/song&gt;
</code></pre>

<h3 id="representable-xml-wrapping-collections" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Wrapping Collections</span></h3>

<p class="">It is sometimes unavoidable to wrap tag lists in a container tag.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::XML

  collection :songs, as: :song, wrap: :songs
end

Album = Struct.new(:songs)
album = Album.new(["Laundry Basket", "Two Kevins", "Wright and Rong"])

album_representer = AlbumRepresenter.new(album)
album_representer.to_xml
</code></pre>

<p class="">Note that <code class="text-purple">:wrap</code> defines the container tag name.</p>

<pre><code class="language-xml">&lt;album&gt;
  &lt;songs&gt;
    &lt;song&gt;Laundry Basket&lt;/song&gt;
    &lt;song&gt;Two Kevins&lt;/song&gt;
    &lt;song&gt;Wright and Rong&lt;/song&gt;
  &lt;/songs&gt;
&lt;/album&gt;
</code></pre>

<h3 id="representable-xml-namespace" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Namespace</span></h3>

<p class="">Namespaces in XML allow the use of different vocabularies, or set of names, in one document. <a href="http://books.xmlschemata.org/relaxng/relax-CHP-11-SECT-1.html" class="underline text-purple">Read this great article</a> to share our fascination about them.</p>

<p class=""><i class="fa fa-download" aria-hidden="true"></i> Where’s the <a href="https://github.com/trailblazer/representable/blob/master/test/xml_namespace_test.rb" class="underline text-purple"><strong>EXAMPLE CODE?</strong></a></p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">The <code class="text-purple">Namespace</code> module is available in Representable &gt;= 3.0.4. It doesn’t work with JRuby due to Nokogiri’s extremely complex implementation. Please wait for Representable 4.0 where we replace Nokogiri.</p>

<p class="">For future-compat: <code class="text-purple">Namespace</code> only works in decorator classes, not modules.</p>

  </div>
</div>

<h4 id="namespace-default">Namespace: Default</h4>

<p class="">You can define <em>one</em> namespace per representer using <code class="text-purple">::namespace</code> to set the section’s default namespace.</p>

<pre><code>{{ "test/xml_namespace_test.rb:simple-class:../representable" | tsnippet }}
</code></pre>

<p class="">Nested representers can be inline or classes (referenced via <code class="text-purple">:decorator</code>). Each class can maintain its own namespace.</p>

<p class="">Without any mappings, the namespace will be used as the default one.</p>

<pre><code>{{ "test/xml_namespace_test.rb:simple-xml:../representable" | tsnippet }}
</code></pre>

<h4 id="namespace-prefix">Namespace: Prefix</h4>

<p class="">After defining the namespace URIs in the representers, you can map them to a document-wide <em>prefix</em> in the top representer via <code class="text-purple">::namespace_def</code>.</p>

<pre><code>{{ "test/xml_namespace_test.rb:map-class:../representable" | tsnippet }}
</code></pre>

<p class="">Note how you can also use <code class="text-purple">:namespace</code> to reference a certain differing prefix per property.</p>

<p class="">When rendering or parsing, the local property will be extended, e.g. <code class="text-purple">/library/book/isbn</code> will become <code class="text-purple">/lib:library/lib:book/lib:isbn</code>.</p>

<pre><code>{{ "test/xml_namespace_test.rb:map-xml:../representable" | tsnippet }}
</code></pre>

<p class="">The top representer will include all namespace definitions as <code class="text-purple">xmlns</code> attributes.</p>

<h4 id="namespace-parse">Namespace: Parse</h4>

<p class="">Namespaces also apply when parsing an XML document to an object structure. When defined, only the known, prefixed tags will be considered.</p>

<pre><code>{{ "test/xml_namespace_test.rb:parse-call:../representable" | tsnippet }}
</code></pre>

<p class="">In this example, only the <code class="text-purple">/lib:library/lib:book/lib:character/hr:name</code> was parsed.</p>

<pre><code>{{ "test/xml_namespace_test.rb:parse-res:../representable" | tsnippet }}
</code></pre>

<p class="">If your incoming document has namespaces, please do use and specify them properly.</p>

<h4 id="namespace-remove">Namespace: Remove</h4>

<p class="">If an incoming document contains namespaces, but you don’t want to define them in your representers, you can automatically remove them.</p>

<pre><code>class AlbumRepresenter &lt; Representable::Decorator
  include Representable::XML

  remove_namespaces!
end
</code></pre>

<p class="">This will ditch the namespace prefix and parse all properties as if they never had any prefix in the document, e.g. <code class="text-purple">lib:author</code> becomes <code class="text-purple">author</code>.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Removing namespaces is a Nokogiri hack. It’s absolutely not recommended as it defeats the purpose of XML namespaces and might result in wrong values being parsed and interpreted.</p>

  </div>
</div>

<h2 id="representable-yaml" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">YAML</span></h2>

<p class="">Representable also comes with a YAML representer. Like <a href="#representable-xml" class="underline text-purple">XML</a>, the declarative API is almost identical.</p>

<h3 id="representable-yaml-flow-style-lists" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Flow Style Lists</span></h3>

<p class="">A nice feature is that <code class="text-purple">#collection</code> also accepts a <code class="text-purple">:style</code> option which helps having nicely formatted inline (or “flow”) arrays in your YAML - if you want that!</p>

<pre><code>require 'representable/yaml'

class SongRepresenter &lt; Representable::Decorator
  include Representable::YAML

  property :title
  property :id
  collection :composers, style: :flow
end
</code></pre>

<h4 id="public-api">Public API</h4>

<p class="">To render and parse, you invoke <code class="text-purple">to_yaml</code> and <code class="text-purple">from_yaml</code>.</p>

<pre><code class="language-ruby">Song = Struct.new(:title, :id, :composers)
song = Song.new("Fallout", 1, ["Stewart Copeland", "Sting"])
SongRepresenter.new(song).to_yaml
</code></pre>

<pre><code class="language-ruby">---
title: Fallout
id: 1
composers: [Stewart Copeland, Sting]
</code></pre>

<h2 id="representable-debugging" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Debugging</span></h2>

<p class="">Representable is a generic mapper using recursions, pipelines and things that might be hard to understand from the outside. That’s why we got the <code class="text-purple">Debug</code> module which will give helpful output about what it’s doing when parsing or rendering.</p>

<p class="">You can extend objects on the run to see what they’re doing.</p>

<pre><code>SongRepresenter.new(song).extend(Representable::Debug).from_json("..")
SongRepresenter.new(song).extend(Representable::Debug).to_json
</code></pre>

<p class="">It’s probably a good idea not to do this in production.</p>

<h2 id="representable-upgrading-guide" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Upgrading Guide</span></h2>

<p class="">We try to make upgrading as smooth as possible. Here’s the generic documentation, but don’t hesitate to ask for <a href="https://gitter.im/trailblazer/chat" class="underline text-purple">help on Gitter</a>.</p>

<h3 id="representable-upgrading-guide-2-4-to-3-0" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">2.4 to 3.0</span></h3>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">The 3.0 line runs with Ruby &gt;2.0, only. This is to make extensive use of keyword arguments.</li>
  <li class="list-image-disc ml-10">All deprecations from 2.4 have been removed.</li>
</ul>

<p class="">to_hash(user_options: {})
-&gt;(options) { options[:user_options] }
-&gt;(user_options:,**) { user_options }</p>

<h3 id="representable-upgrading-guide-2-3-to-2-4" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">2.3 to 2.4</span></h3>

<p class="">The 2.4 line contains many new features and got a major internal restructuring. It is a transitional release with deprecations for all changes.</p>

<h4 id="breakage">Breakage</h4>

<pre><code>:render_filter =&gt; lambda { |val, options| "#{val.upcase},#{options[:doc]},#{options[:options][:user_options]}" }
</code></pre>

<h4 id="deprecations">Deprecations</h4>

<p class="">Once your code is migrated to 2.4, you should upgrade to 3.0, which does <em>not</em> have deprecations anymore and only supports Ruby 2.0 and higher.</p>

<p class="">If you can’t upgrade to 3.0, you can disable slow and annoying deprecations as follows.</p>

<pre><code>Representable.deprecations = false
</code></pre>

<h4 id="positional-arguments">Positional Arguments</h4>

<p class="">For dynamic options like <code class="text-purple">:instance</code> or <code class="text-purple">:getter</code> we used to expose a positional API like <code class="text-purple">instance: -&gt;(fragment, options)</code> where every option has a slightly different signature. Even worse, for <code class="text-purple">collection</code>s this would result in a differing signature plus an index like <code class="text-purple">instance: -&gt;(fragment, index, options)</code>.</p>

<p class="">From Representable 2.4 onwards, only one argument is passed in for all options with an identical, easily memoizable API. Note that the old signatures will print deprecation warnings, but still work.</p>

<p class="">For parsing, this is as follows (<code class="text-purple">:instance</code> is just an example).</p>

<pre><code>property :artist, instance: -&gt;(options) do
  options[:input]
  options[:fragment] # the parsed fragment
  options[:doc]      # the entire document
  options[:result]   # whatever the former function returned,
                     # usually this is the deserialized object.
  options[:user_options] # options passed into the parse method (e.g. from_json).
  options[:index]    # index of the currently iterated fragment (only with collection)
end
</code></pre>

<p class="">We highly recommend to use keyword arguments if you’re using Ruby 2.1+.</p>

<pre><code>property :artist, instance: -&gt;(fragment:, user_options:, **) do
</code></pre>

<h4 id="user-options">User Options</h4>

<p class="">When passing dynamic options to <code class="text-purple">to_hash</code>/<code class="text-purple">from_hash</code> and friends, in older version you were allowed to pass in the options directly.</p>

<pre><code>decorator.to_hash(is_admin: true)
</code></pre>

<p class="">This is deprecated. You now have to use the <code class="text-purple">:user_options</code> key to make it compatible with library options.</p>

<pre><code>decorator.to_hash(user_options: { is_admin: true })
</code></pre>

<h4 id="pass-options">Pass Options</h4>

<p class="">The <code class="text-purple">:pass_options</code> option is deprecated and you should simply remove it, even though it still works in &lt; 3.0. You have access to all the environmental object via <code class="text-purple">options[:binding]</code>.</p>

<p class="">In older version, you might have done as follows.</p>

<pre><code>property :artist, pass_options: true,
  instance: -&gt;(fragment, options) { options.represented }
</code></pre>

<p class="">Runtime information such as <code class="text-purple">represented</code> or <code class="text-purple">decorator</code> is now available via the generic options.</p>

<pre><code>property :artist, instance: -&gt;(options) do
  options[:binding]              # property Binding instance.
  options[:binding].represented  # the represented object
  options[:user_options]         # options from user.
end
</code></pre>

<p class="">The same with keyword arguments.</p>

<pre><code>property :artist, instance: -&gt;(binding:, user_options:, **) do
  binding.represented  # the represented object
end
</code></pre>

<h4 id="parse-strategy">Parse Strategy</h4>

<p class="">The <code class="text-purple">:parse_strategy</code> option is deprecated in favor of <code class="text-purple">:populator</code>. Please replace all occurrences with the new populator style to stay cool.</p>

<p class="">If you used a <code class="text-purple">:class</code> proc with <code class="text-purple">:parse_strategy</code>, the new API is <code class="text-purple">class: -&gt;(options)</code>. It used to be <code class="text-purple">class: -&gt;(fragment, user_options)</code>.</p>

<h4 id="class-and-instance">Class and Instance</h4>

<p class="">In older versions you could use <code class="text-purple">:class</code> and <code class="text-purple">:instance</code> in combination, which resulted in hard-to-follow behavior. These options work exclusively now.</p>

<h4 id="skiprender">SkipRender</h4>

<pre><code>skip_render: lambda { |options|
# raise options[:represented].inspect
        options[:user_options][:skip?] and options[:input].name == "Rancid"
</code></pre>

<h4 id="binding">Binding</h4>

<p class="">The <code class="text-purple">:binding</code> option is deprecated and will be removed in 3.0. You can use your own pipeline and replace the <code class="text-purple">WriteFragment</code> function with your own.</p>

        </div>

            <!-- 5.5rem is lg navbar height -->
        <div class="bg-white h-screen w-56 sticky top-[5.5rem]" id="right-toc">
          <div id="docsearch" class="flex flex-col w-[203px] pt-5"></div>

          <div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22" id="right-toc-representable-api">
  <h4 class="font-base font-bold leading-10 pl-2">
     API
  </h4>

  
    <a class="block px-2 leading-8" href="#representable-api-declarative-api">Declarative API</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-feature">Feature</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-execution-context">Execution Context</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-callable-options">Callable Options</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-read-write-restrictions">Read/Write Restrictions</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-coercion">Coercion</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-symbol-keys">Symbol Keys</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-defaults">Defaults</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-standalone-hash">Standalone Hash</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-standalone-collection">Standalone Collection</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-standalone-collection-to_a">Standalone Collection: to_a</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-automatic-collection-representer">Automatic Collection Representer</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-automatic-singular-and-collection">Automatic Singular and Collection</a>

    
  
    <a class="block px-2 leading-8" href="#representable-api-public-api">Public API</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22" id="right-toc-representable-function-api">
  <h4 class="font-base font-bold leading-10 pl-2">
     Function API
  </h4>

  
    <a class="block px-2 leading-8" href="#representable-function-api-overview">Overview</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-options">Options</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-as">As</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-getter">Getter</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-setter">Setter</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-if">If</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-reader">Reader</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-writer">Writer</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-skip-parse">Skip Parse</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-skip-render">Skip Render</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-parse-filter">Parse Filter</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-render-filter">Render Filter</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-deserialize">Deserialize</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-serialize">Serialize</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-extend">Extend</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-prepare">Prepare</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-class">Class</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-instance">Instance</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-render-nil">Render Nil</a>

    
  
    <a class="block px-2 leading-8" href="#representable-function-api-render-empty">Render Empty</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22" id="right-toc-representable-xml">
  <h4 class="font-base font-bold leading-10 pl-2">
     XML
  </h4>

  
    <a class="block px-2 leading-8" href="#representable-xml-tag-attributes">Tag Attributes</a>

    
  
    <a class="block px-2 leading-8" href="#representable-xml-mapping-content">Mapping Content</a>

    
  
    <a class="block px-2 leading-8" href="#representable-xml-wrapping-collections">Wrapping Collections</a>

    
  
    <a class="block px-2 leading-8" href="#representable-xml-namespace">Namespace</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22" id="right-toc-representable-yaml">
  <h4 class="font-base font-bold leading-10 pl-2">
     YAML
  </h4>

  
    <a class="block px-2 leading-8" href="#representable-yaml-flow-style-lists">Flow Style Lists</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22" id="right-toc-representable-debugging">
  <h4 class="font-base font-bold leading-10 pl-2">
     Debugging
  </h4>

  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22" id="right-toc-representable-upgrading-guide">
  <h4 class="font-base font-bold leading-10 pl-2">
     Upgrading Guide
  </h4>

  
    <a class="block px-2 leading-8" href="#representable-upgrading-guide-2-4-to-3-0">2.4 to 3.0</a>

    
  
    <a class="block px-2 leading-8" href="#representable-upgrading-guide-2-3-to-2-4">2.3 to 2.4</a>

    
  
</div>


        </div>
      </div>
    </div>
  </div>
</section>


<footer class="lg:text-left bg-bg-blue py-16 text-white text-center text-base">
  <div class="lg:flex justify-between w-11/12 max-w-[80rem] mx-auto">
    <div class="lg:flex lg:flex-col lg:justify-between">
      <a href="/2.1/" class="block shrink-0 w-fit mx-auto lg:mx-0" >
        <img class="w-48" src="/assets/logo_white_ruby-01c45713d0879788514c52d65ac53e92d7735b42cec0baf6e080b08f9a0fb595.svg" />
      </a>
      <div class="lg:block hidden">
        © 2023 Trailblazer GmbH

      </div>
    </div>
    <div class="lg:flex lg:gap-20 xl:gap-40">
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl" href="/2.1/docs/trailblazer/">Documentation</a>
        <a href="/2.1/docs/trailblazer/#trailblazer-learn-trailblazer-tales">Videos</a>
        <a href="/2.1/docs/trailblazer/">API</a>
        <a href="/2.1/docs/operation/">Operation</a>
      </div>
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl" href="/2.1/about/">About us</a>
        <div class="flex items-center">
          <a href="https://www.linkedin.com/company/trailblazer-gmbh/">LinkedIn</a>
          <a href="https://www.linkedin.com/company/trailblazer-gmbh/">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fill-white pl-2" height="1.3em"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
          </a>
        </div>
        <a href="https://dev.to/trailblazer">Blog</a>
        <a href="/2.1/about/">Trailblazer GmbH</a>
        <a href="/2.1/pro/">Trailblazer PRO</a>
      </div>
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl" href="https://trailblazer.zulipchat.com">Help</a>
        <a href="https://trailblazer.zulipchat.com">Chat</a>
        <a href="http://eepurl.com/hHE3a5">Newsletter</a>
      </div>
    </div>
  </div>
  <div class="lg:hidden mt-15">
    © 2023 Trailblazer GmbH
  </div>
</footer>


  </body>
</html>
