<%= h2 "Mechanics" %>

This chapter discusses the fundamental building blocks and concepts of operations: steps, signals, the ctx object and how to run operations.

<%= h3 "Invocation" %>

Operations represent functions in your application, both in a domain-oriented way and from a programmatical point of view. That is why there's only one way to run an operation.

<%= h4 "Call" %>

The `#call` class method is how you run your operation along with its steps.

<%= code "instance-method-call" %>

And that's literally the only way to invoke your steps. It is not allowed to run a subset of steps, only. If you need that, you might have to introduce a new operation, or [change the wiring](#activity-wiring-api) to achieve the same effect.

<%= h4 "Implicit call" %>

In Ruby, it's possible to skip the word `call`. That's why you might often see invocations of operations that might look a bit cryptic in the beginning.

<%= code "instance-method-implicit-call" %>

Anyhow, the implicit call style underlines the functional aspect of an operation. Since, per convention, the operation name is a verb (e.g. `Create`) there's no need to think of another verb to actually _run_ that "verb". That's why we love the implicit call style!

<%= h4 "Input variables" %>

Any variables you pass into the invocation will be readable by all steps of the operation (unless configured otherwise).

<%= code "ctx-read-call" %>

Here, the `:params` variable can be accessed in each step via the `ctx` object, which is the first positional argument passed to each step.

<%= code "ctx-read", collapse: :meths %>

While this is a breathtaking feature of Trailblazer, it's a bit clumsy and we got a more convenient way to read from `ctx`.

<%= h4 "Keyword arguments" %>

Instead of manually checking `ctx` for the presence of a particular variable, you can add a keyword argument to your step's signature.

<%= code "ctx-read-kwargs" %>

The `:params` variable is now a local variable `params` in your step method.

Another benefit: if the caller of your operation fails to provide `:params`, Ruby will complain automatically of a missing keyword!

<%= code "kwargs-error" %>

Ruby's epic [keyword arguments](https://thoughtbot.com/blog/ruby-2-keyword-arguments) even allow defaulting of variables, should they be absent in `ctx`.

Note that you can use any number of keyword arguments in your signature.

<%= h4 "Writing state" %>

It is also possible to _write_ to `ctx`, should you fancy to publish information out of the step.

<%= code "ctx-write" %>

The following steps will be able to read the `:model` variable exactly the same way it worked with `:params`.

<%= code "ctx-write-read", collapse: :body %>

Keep in mind that the above is the default behavior. You may configure what comes in and goes out of a step using [variable mapping](#activity-variable-mapping).

<%= h3 "Flow control" %>

When being invoked with `#call`, the operation works off its steps in the order they were defined with `#step`. This is called the "happy path", or the success track.

<%= image_tag "memo-create.png" %>


Once a step returns a "failure", the operation will deviate to the "failure track" and skip the remaining steps on the success track. Instead, the remaining steps added using `#left` (formerly `#fail`) will be executed.

Steps can communicate their outcome to the operation's flow control with their return value.

<%= h4 "Success" %>

The `#validate` step in our example does a simple check to see if `params[:memo]` is present.

<%= code "return-success" %>

Since this is the only line in the method, the return value will be either true, signalizing a successful validation, or false, indicating there's a formal problem with the incoming user data.

The return value doesn't have to `true` or `false`, but can be any "truthy" or "falsey" (e.g. `nil`) value.

<%= h4 "Failure" %>

A falsey return value will deviate the operation's path to the failure track.

<%= code "return-failure" %>

This depressive step will always return a falsey value (`nil` is evaluated to `false`), the remaining success path steps will always be skipped. Don't do this!

<%= h4 "Signal" %>

The binary `true`/`false` outcome is useful for many scenarios. However, sometimes a step might have a third outcome - for example, to indicate a network error that needs to be handled off the failure track.

<%= code "return-signal" %>

In this step, we're returning a "third" possible value. The trick is: the `NetworkError` needs to be a subclass of `Signal`.

<%= code "signal-operation", collapse: :meths %>

That way, the operation's routing will recognize this third outcome. Speaking of, the third scenario needs to be properly connected using the [Wiring API](#activity-wiring-api).

<%= code "signal-steps" %>

Here, `#notify` encountering a disastrous network error will make the operation stop executing in a new, third terminus called `network_error`.

Check out the Wiring API to learn how to leverage multiple outcomes in operations.

<%= h3 "Step" %>

An operation can be composed of any number of steps. Steps can be callable Ruby objects or instance methods of the operation itself.

<%= h4 "Instance method" %>

A step declared with a `:symbol`, as done here with `#validate`, will be considered an instance method of the operation class.

<%= code "instance-method" %>

Signature and return value are identical to all other step types.

<%= h4 "Class method" %>

A class method can come in handy if you want to reuse this particular step in an entirely different operation.

<%= code "class-method" %>

Note that the actual class method has to be defined before retrieving the method object via `method(:validate)`. Again, signature and return value are identical to other styles.

<%= h4 "Module method" %>

Just like a class method, steps can come from any module - this makes it straight-forward to create reusable chunks of logic.

<%= code "module-step" %>

The mechanics to use a "foreign" method as a step are identical to using a class method - they simply rely on [Ruby's `#method` function](https://ruby-doc.org/3.2.2/Method.html).

<%= code "module-method" %>

This is a common technique in complex Trailblazer applications for creating reusable steps with a high degree of maintainability.

<%= h4 "Callable" %>

As a matter of fact, any object, module or class exposing a `#call` method can be a step!

<%= code "callable-step" %>

Callable objects are often used when the step's logic exceeds a certain threshold of complexity and you want to introduce additional methods, as the above `#valid?` function.

<%= info do %>
Keep in mind that a step can also be implemented using a second *operation*. You can use the [`Subprocess()` macro](#activity-wiring-api-subprocess) to nest operations.
<% end -%>

<%= h4 "Lambda" %>

Another trick, mostly used for debugging, is to use a lambda as a step.

<%= code "lambda-step" %>

Obviously, this is not really sustainable and should be replaced with one of the above options.

<%= h3 "Ctx" %>

ctx#[]
keyword arguments
ctx#[]=


return value FLOW CONTROL
Signal
result
termini
circuit interface

invocation
